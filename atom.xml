<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[潭风]]></title>
  <link href="http://senola.github.io/atom.xml" rel="self"/>
  <link href="http://senola.github.io/"/>
  <updated>2015-03-09T20:45:05+08:00</updated>
  <id>http://senola.github.io/</id>
  <author>
    <name><![CDATA[senola]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[那些年，在前端路上踩过的的坑]]></title>
    <link href="http://senola.github.io/blog/2015/02/27/the-bug-of-fontend/"/>
    <updated>2015-02-27T21:38:35+08:00</updated>
    <id>http://senola.github.io/blog/2015/02/27/the-bug-of-fontend</id>
    <content type="html"><![CDATA[<p>大千世界，齐路万千。一不小心踩坑，深陷囵圄。几番周折，才得以逃脱。。。痛，来自爱。因爱生痛，痛的彻底，痛的刻骨。大爱前端，所以逢坑必填。试想，多年之后回首，万千平路，皆吾填之。故，坑，必填也。</p>

<!--more-->


<h3><a name="list">目录</a></h3>

<ul>
<li><a href="#0001" class="senola-a">一、input框设置width:100%溢出父类容器</a></li>
<li><a href="#0002" class="senola-a">二、safari下input输入框有内描边及webkit css 整理</a></li>
<li><a href="#0003" class="senola-a">三、移动端最佳使用单位](#0003)</a></li>
<li><a href="#0004" class="senola-a">四、模拟:hover伪类</a></li>
<li><a href="#0005" class="senola-a">五、input类型为date情况下不支持placeholder</a></li>
<li><a href="#0006" class="senola-a">六、active的兼容</a></li>
<li><a href="#0007" class="senola-a">七、测试是否支持svg</a></li>
<li><a href="#0008" class="senola-a">八、ios下的隐私模式</a></li>
<li><a href="#0009" class="senola-a">九、关于 iOS 系统中，中文输入法输入英文时，字母之间可能会出现一个六分之一空格</a></li>
<li><a href="#0010" class="senola-a">十、关于音频跟视频</a></li>
</ul>


<h3><a name="0001">一、input框设置width:100%,溢出父类容器</a></h3>

<p>2014,已去！为迎接新的一年公司会在除夕之时搞一场大型活动。而我，有幸参与此次活动的研发。是的，坑就是在这中情况下来的。</p>

<p>我们知道，浏览器是一种很神奇的东西（此处省略一万字）。各种奇形怪状，杂七杂八的BUG随处可见。这不，我就在input标签中踩着了。。。</p>

<p><strong>情景：</strong> 项目引入了标准的normalize.css, 整个页面设在一个<code>&lt;div class="container"&gt;&lt;/div&gt;</code>下，由她来控制整个文档流整体的在页面中的显示（如居中，与两边的宽度等）。之后在其内部有一个input输入框，为了让其跨浏览器显示一般我们会将元素的宽度设置成百分比，即设置input的宽度为“100%”，那么问题来了：在PC浏览器上显示正常，但在移动端偏偏input越界了。这令我很是费解，尝试了N中方法就是不行，差点就选择用绝对长度来定位了。如下图：</p>

<p><img src="https://raw.githubusercontent.com/senola/pictures/master/css/input/input-width-100%25-wrong.png" alt="input-width-100%25-wrong.png" /></p>

<p><strong>解决方法：</strong>没事找我，有事找谷歌。overstack是个好东西，几乎你遇到的问题别人都遇到过了。结果增加了以下代码就ok了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>input {   
</span><span class='line'> width: 100%;     
</span><span class='line'> box-sizing: border-box;   
</span><span class='line'> -webkit-box-sizing:border-box;   
</span><span class='line'> -moz-box-sizing: border-box;   
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>效果如下：</p>

<p><img src="https://raw.githubusercontent.com/senola/pictures/master/css/input/input-wdth-100%25-ok.png" alt="input-wdth-100%25-ok.png" /></p>

<p>那么这究竟是为什么呢？为此特意去study了一下&hellip;</p>

<p>我们知道每一个元素都有一个盒模型，而世界上存在两种计算元素宽度的方式： 一种是W3C的标准（宽度及为元素的宽度，不包括padding和border），另一种是传统的盒模型（宽度包括了了元素自身的宽度再加上padding和border）。</p>

<p>浏览器一般都是默认按照W3C标准盒模型来计算元素宽度的（除了IE的“Quirks Mode”）.</p>

<p>比如：两种模式下相同样式不同结果</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.demo {
</span><span class='line'>  width: 250px;
</span><span class='line'>  height: 100px;
</span><span class='line'>  border: 5px solid #6374AB;
</span><span class='line'>  padding: 10px;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>第一个使用传统的盒模型，第二个使用W3C的盒模型，效果如下：</p>

<p><img src="https://raw.githubusercontent.com/senola/pictures/master/css/box-model/box.gif" alt="box.gif" /></p>

<p>区别很明显，传统的盒模型中元素的宽度就是content + padding + border,而
W3C的盒模型中元素的宽度是content。这就解释了为什么input输入框设置了100%会超出父类宽度了。因为当时环境中是width=100%，但padding和border不包括在这100%的宽度中，故渲染出来的宽度大于100%。</p>

<p>显然，按照传统的盒模型比较好控制。css3中出现了<code>box-sizing</code>属性，允许你切换盒模型：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>box-sizing: border-box;
</span><span class='line'>box-sizing: content-box;</span></code></pre></td></tr></table></div></figure>


<p><code>box-sizing: border-box</code>表示元素的大小是包括border以内的所有宽度，即传统盒模型，而<code>box-sizing: content-box</code>表示元素的宽度即content的宽度，不包括<code>padding、border</code>。</p>

<p><code>Mozilla</code>支持<code>padding-box</code>,即表示元素的大小是padding以内的宽度，不包括<code>border</code>。</p>

<p>更精确的测试如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> div.test {
</span><span class='line'>  width: 300px;
</span><span class='line'>  padding: 10px;
</span><span class='line'>  border: 5px solid #000000;
</span><span class='line'>  margin-left: 10%;
</span><span class='line'>  margin-bottom: 10px;
</span><span class='line'>  margin-top: 10px;
</span><span class='line'> }</span></code></pre></td></tr></table></div></figure>


<p>效果如下：</p>

<p><img src="https://raw.githubusercontent.com/senola/pictures/master/css/box-model/box-model-test.png" alt="box-model-test.png" /></p>

<p>经此一役，恍然大悟。于是在normalize.css加上一下代码，确保万无一失：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*清除浮动*/
</span><span class='line'>.clearfix:before, .clearfix:after {
</span><span class='line'>  content: '';
</span><span class='line'>  display: table;
</span><span class='line'>}
</span><span class='line'>.clearfix:after {
</span><span class='line'>  clear: both;
</span><span class='line'>  overflow: hidden;
</span><span class='line'>}
</span><span class='line'>.clearfix {
</span><span class='line'>  zoom: 1;
</span><span class='line'>}
</span><span class='line'>/*设置所有元素为传统盒模型*/
</span><span class='line'>*,
</span><span class='line'>*:before,
</span><span class='line'>*:after {
</span><span class='line'>  -webkit-box-sizing: border-box;
</span><span class='line'>  -moz-box-sizing: border-box;
</span><span class='line'>  box-sizing: border-box;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3><a name="0002">二、safari下input输入框有内描边及webkit css 整理</a></h3>

<p>webkit内核浏览器默认会给input输入框加上内描边，这对专业的设计师来说是不能容忍的。而前端叉子们就得想尽办法出去她~ 多悲伤啊，人家浏览器也是为了你好，至于么？？？？  代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>input {
</span><span class='line'>   -webkit-appearance: none; // Safari 去掉内阴影
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>移动端中，使用click会出现绑定点击区域有高亮背景，修改背景颜色方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  input{
</span><span class='line'>  -webkit-tap-highlight-color: rgba(0,0,0,0); // 设置点击区域的颜色
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p>ios中滑动效果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>body{
</span><span class='line'>  -webkit-overflow-scrolling: touch;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>好吧，webkit属性太多，整体把握才是王道，于是整理如下：</p>

<h5>1. &ldquo;box model&#8221;相关，包括content、padding、margin等</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-webkit-border-bottom-left-radius: radius;
</span><span class='line'>-webkit-border-top-left-radius: horizontal_radius vertical_radius;
</span><span class='line'>-webkit-border-radius: radius;      //容器圆角
</span><span class='line'>-webkit-box-sizing: sizing_model; 边框常量值：border-box/content-box
</span><span class='line'>-webkit-box-shadow: hoff voff blur color; //容器阴影（参数分别为：水平X 方向偏移量；垂直Y 方向偏移量；高斯模糊半径值；阴影颜色值）
</span><span class='line'>-webkit-margin-bottom-collapse: collapse_behavior; 常量值：collapse/discard/separate
</span><span class='line'>-webkit-margin-start: width;
</span><span class='line'>-webkit-padding-start: width;
</span><span class='line'>-webkit-border-image: url(borderimg.gif) 25 25 25 25 round/stretch round/stretch;
</span><span class='line'>-webkit-appearance: push-button;   //内置的CSS 表现，暂时只支持push-button
</span></code></pre></td></tr></table></div></figure>


<h5>2. 视觉格式化模型”描述性质，确定了位置和大小的块元素</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>clip: rect(10px, 5px, 10px, 5px)
</span><span class='line'>resize: auto; 常量：auto/both/horizontal/none/vertical
</span><span class='line'>visibility: visible; 常量: collapse/hidden/visible
</span><span class='line'>-webkit-transition: opacity 1s linear; 动画效果 ease/linear/ease-in/ease-out/ease-in-out
</span><span class='line'>-webkit-backface-visibility: visibler; 常量：visible(默认值)/hidden
</span><span class='line'>-webkit-box-reflect: right 1px; //镜向反转
</span><span class='line'>-webkit-box-reflect: below 4px -webkit-gradient(linear, left top, left bottom,from(transparent), color-stop(0.5, transparent), to(white));
</span><span class='line'>-webkit-mask-image: -webkit-gradient(linear, left top, left bottom, from(rgba(0,0,0,1)), to(rgba(0,0,0,0)));;   //CSS 遮罩/蒙板效果
</span><span class='line'>-webkit-mask-attachment: fixed; 常量：fixed/scroll
</span><span class='line'>-webkit-perspective: value; 常量：none(默认)
</span><span class='line'>-webkit-perspective-origin: left top;
</span><span class='line'>-webkit-transform: rotate(5deg);
</span><span class='line'>-webkit-transform-style: preserve-3d; 常量：flat/preserve-3d; (2D 与3D)</span></code></pre></td></tr></table></div></figure>


<h5>3.“颜色和背景”描述属性控制背景下的块级元素和颜色的文本内容的组成部分</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-webkit-background-clip: content; 常量：border/content/padding/text
</span><span class='line'>-webkit-background-origin: padding; 常量：border/content/padding/text
</span><span class='line'>-webkit-background-size: 55px; 常量：length/length_x/length_y</span></code></pre></td></tr></table></div></figure>


<h5>4. “文本”描述属性的特定文字样式，间距和自动滚屏</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> text-shadow: #00FFFC 10px 10px 5px;
</span><span class='line'> text-transform: capitalize; 常量：capitalize/lowercase/none/uppercase
</span><span class='line'> word-wrap: break-word; 常量：break-word/normal
</span><span class='line'>-webkit-marquee: right large infinite normal 10s; 常量：direction(方向) increment(迭代次数) repetition(重复) style(样式) speed(速度);
</span><span class='line'>-webkit-marquee-direction: ahead/auto/backwards/down/forwards/left/reverse/right/up
</span><span class='line'>-webkit-marquee-incrementt: 1-n/infinite(无穷次)
</span><span class='line'>-webkit-marquee-speed: fast/normal/slow
</span><span class='line'>-webkit-marquee-style: alternate/none/scroll/slide
</span><span class='line'>-webkit-text-fill-color: #ff6600; 常量：capitalize, lowercase, none, uppercase  
</span><span class='line'>-webkit-text-security: circle; 常量：circle/disc/none/square  // 如密码输入框使用该属性
</span><span class='line'>-webkit-text-size-adjust: none; 常量:auto/none; //阻止屏幕旋转时字体自动调整
</span><span class='line'>-webkit-text-stroke: 15px #fff;
</span><span class='line'>-webkit-line-break: after-white-space; 常量：normal/after-white-space
</span><span class='line'>-webkit-appearance: caps-lock-indicator;
</span><span class='line'>-webkit-nbsp-mode: space; 常量： normal/space
</span><span class='line'>-webkit-rtl-ordering: logical; 常量：visual/logical
</span><span class='line'>-webkit-user-drag: element; 常量：element/auto/none
</span><span class='line'>-webkit-user-modify: read-only; 常量：read-write-plaintext-only/read-write/read-only
</span><span class='line'>-webkit-user-select: text; 常量：text/auto/none  // 是否允许用户选中文本
</span><span class='line'>-webkit-touch-callout:none  //禁止 iOS 弹出各种操作窗口
</span><span class='line'>input::-webkit-input-speech-button {display: none} // Andriod 上去掉语音输入按钮</span></code></pre></td></tr></table></div></figure>


<h5>5. “表格”描述的布局和设计性能表的具体内容</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-webkit-border-horizontal-spacing: 2px;
</span><span class='line'>-webkit-border-vertical-spacing: 2px;
</span><span class='line'>-webkit-column-break-after: right; 常量：always/auto/avoid/left/right
</span><span class='line'>-webkit-column-break-before: right; 常量：always/auto/avoid/left/right
</span><span class='line'>–webkit-column-break-inside: logical; 常量：avoid/auto
</span><span class='line'>-webkit-column-count: 3; //分栏
</span><span class='line'>-webkit-column-rule: 1px solid #fff;
</span><span class='line'>style:dashed,dotted,double,groove,hidden,inset,none,outset,ridge,solid</span></code></pre></td></tr></table></div></figure>


<h5>6. “用户界面”描述属性，涉及到用户界面元素在浏览器中，如滚动文字区，滚动条，等等</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-webkit-box-align: baseline,center,end,start,stretch 常量：baseline/center/end/start/stretch
</span><span class='line'>-webkit-box-direction: normal;常量：normal/reverse
</span><span class='line'>-webkit-box-flex: flex_valuet
</span><span class='line'>-webkit-box-flex-group: group_number
</span><span class='line'>-webkit-box-lines: multiple; 常量：multiple/single
</span><span class='line'>-webkit-box-ordinal-group: group_number
</span><span class='line'>-webkit-box-orient: block-axis; 常量：block-axis/horizontal/inline-axis/vertical/orientation
</span><span class='line'>–webkit-box-pack: alignment; 常量：center/end/justify/start</span></code></pre></td></tr></table></div></figure>


<h5>7. 动画过渡</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-webkit-animation: title infinite ease-in-out 3s;
</span><span class='line'>animation 有这几个属性：
</span><span class='line'>-webkit-animation-name： //属性名，就是我们定义的keyframes
</span><span class='line'>-webkit-animation-duration：3s //持续时间
</span><span class='line'>-webkit-animation-timing-function： //过渡类型：ease/ linear(线性) /ease-in(慢到快)/ease-out(快到慢) /ease-in-out(慢到快再到慢) /cubic-bezier
</span><span class='line'>-webkit-animation-delay：10ms //动画延迟(默认0)
</span><span class='line'>-webkit-animation-iteration-count： //循环次数(默认1)，infinite 为无限
</span><span class='line'>-webkit-animation-direction： //动画方式：normal(默认 正向播放)； alternate(交替方向，第偶数次正向播放，第奇数次反向播放)</span></code></pre></td></tr></table></div></figure>


<h3><a name="0003">三、移动端最佳使用单位</a></h3>

<p>移动端使用什么单位是开发者最迫切需要知道的，px、%、pt、em 还是rem？ 当然是rem。rem是非常好用的一个属性，可以根据html来设定基准值，而且兼容性也很不错。不过有的时候还是需要对一些莫名其妙的浏览器优雅降级。可以用以下的代码片段保证在低端浏览器下也不会出问题：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>html { font-size: 62.5%; }
</span><span class='line'>body { font-size: 14px; font-size: 1.4rem; } /* =14px */
</span><span class='line'>h1   { font-size: 24px; font-size: 2.4rem; } /* =24px */</span></code></pre></td></tr></table></div></figure>


<h3><a name="0004">四、模拟:hover伪类</a></h3>

<p>由于移动端没有鼠标指针，所以没有hover事件，所以css:hover伪类就没用了。但是移动端有touch事件，onTouchStart 类似 onMouseOver，onTouchEnd 类似 onMouseOut。所以我们可以用它来模拟hover。使用Javascript：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var myLinks = document.getElementsByTagName('a');
</span><span class='line'>for(var i = 0, len = myLinks.length ; i &lt; len; i++){
</span><span class='line'>　　myLinks[i].addEventListener(’touchstart’, function(){this.className = “hover”;}, false);
</span><span class='line'>　　myLinks[i].addEventListener(’touchend’, function(){this.className = “”;}, false);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后用css增加hover效果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a:hover, a:hover {/* 你要的效果*/}</span></code></pre></td></tr></table></div></figure>


<p>这样设计一个链接，感觉可以更像按钮。并且，这个模拟可以用在任何元素上。</p>

<h3><a name="0005">五、input类型为date情况下不支持placeholder</a></h3>

<p>由于浏览器会针对date类型的input增加datepicker模块，所以有些系统不支持placeholder:</p>

<p>桌面端（Mac）
&ndash; Safari 不支持 datepicker，placeholder 正常显示。
&ndash; Firefox 不支持 datepicker，placeholder 正常显示。
&ndash; Chrome 支持 datepicker，显示 年、月、日 格式，忽略placeholder。</p>

<p>移动端
&ndash; iPhone5 iOS7 有 datepicker 功能，但是不显示 placeholder。
&ndash; Andorid 4.0.4 无 datepicker 功能，不显示 placeholder</p>

<p>解决方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;input placeholder="Date" class="textbox-n" type="text" onfocus="(this.type='date')"  id="date"&gt;</span></code></pre></td></tr></table></div></figure>


<p>因为text是支持placeholder的。因此当用户focus的时候自动把type类型改变为date，这样既有placeholder也有datepicker了。</p>

<h3><a name="0006">六、active的兼容</a></h3>

<p>要让a链接的CSS active伪类生效，只需要给这个a链接的touch系列的任意事件touchstart/touchend绑定一个空的匿名方法即可hack成功:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;style&gt;
</span><span class='line'>  a {
</span><span class='line'>  color: #000;
</span><span class='line'>  }
</span><span class='line'>  a:active {
</span><span class='line'>  color: #fff;
</span><span class='line'>  }
</span><span class='line'>&lt;/style&gt;
</span><span class='line'>&lt;a herf=”asdasd”&gt;asdasd&lt;/a&gt;
</span><span class='line'>&lt;script&gt;
</span><span class='line'>  var a=document.getElementsByTagName(‘a’);
</span><span class='line'>  for(var i=0;i&lt;a.length;i++){
</span><span class='line'>  a[i].addEventListener(‘touchstart’,function(){},false);
</span><span class='line'>  }
</span><span class='line'>&lt;/script&gt;</span></code></pre></td></tr></table></div></figure>


<h3><a name="0007">七、测试是否支持svg</a></h3>

<p>用以下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>document.implementation.hasFeature("http:// www.w3.org/TR/SVG11/feature#Image", "1.1");</span></code></pre></td></tr></table></div></figure>


<h3><a name="0008">八、ios下的隐私模式</a></h3>

<p>这个“隐私模式”是最容易被忽视的。ios的safari提供一种“隐私模式”，如果你的webapp没有考虑这个兼容模式，那么在使用html5的本地存储的“localstorage”时，可能因为“隐私模式”下没有权限读写localstorage而使代码抛出错误，导致后续的js代码无法运行~</p>

<p>所以在使用localstorage的时候，首先应该判断是否支持localstorage。但是问题又来了：测试发现，即使在safari的“隐私模式”下，’localStorage’ in window的返回值依然为true，也就是不能用“&#8217;localStorage&#8217; in window”来判断。接下来只能相当使用try catch了，虽然这是一个不太推荐被使用的方法，使用try catch捕获错误，使后续的js代码可以继续运行，代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>try{
</span><span class='line'>    if('localStorage' in window){
</span><span class='line'>         //需要使用localStorage的代码写在这
</span><span class='line'>    }else{
</span><span class='line'>         //不支持的提示和向下兼容代码
</span><span class='line'>    }
</span><span class='line'>}catch(e){
</span><span class='line'>    // 隐私模式相关提示代码和不支持的提示和向下兼容代码
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>所以，在需要兼容ios的safari的“隐私模式”的情况下，本地存储相关的代码需要使用try catch包裹并降级兼容。如果不知道的话，呵呵，那就惨了！！！！！</p>

<h3><a name="0009">九、中文输入法输入英文，字母之间可能会出现一个六分之一空格</a></h3>

<p>关于 iOS 系统中，中文输入法输入英文时，字母之间可能会出现一个六分之一空格，可以使用正则表达式过滤：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>this.value = this.value.replace(/\u2006/g, '');</span></code></pre></td></tr></table></div></figure>


<h3><a name="0010">十、关于音频跟视频</a></h3>

<p>代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;audio autoplay&gt;
</span><span class='line'>  &lt;source  src="audio/alarm1.mp3" type="audio/mpeg"&gt;
</span><span class='line'>&lt;/audio&gt;</span></code></pre></td></tr></table></div></figure>


<p>如上代码，系统默认情况下audio的autoplay属性是无法生效的，这也是手机为节省用户流量做的考虑。如果必须要自动播放，有两种方式可以解决。</p>

<h5>1.捕捉一次用户输入后，让音频加载，下次即可播放</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//play and pause it once
</span><span class='line'>document.addEventListener('touchstart', function () {
</span><span class='line'>    document.getElementsByTagName('audio')[0].play();
</span><span class='line'>    document.getElementsByTagName('audio')[0].pause();
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>这种方法需要捕获一次用户的点击事件来促使音频跟视频加载。当加载后，你就可以用javascript控制音频的播放了，如调用audio.play().</p>

<h5>2. 利用iframe加载资源</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var ifr=document.createElement("iframe");
</span><span class='line'>ifr.setAttribute('src', "http://mysite.com/myvideo.mp4");
</span><span class='line'>ifr.setAttribute('width', '1px');
</span><span class='line'>ifr.setAttribute('height', '1px');
</span><span class='line'>ifr.setAttribute('scrolling', 'no');
</span><span class='line'>ifr.style.border="0px";
</span><span class='line'>document.body.appendChild(ifr);</span></code></pre></td></tr></table></div></figure>


<p>这种方式其实跟第一种原理是一样的。当资源加载了你就可以控制播放了，但是这里使用iframe来加载，相当于直接触发资源加载。 注意，使用创建audio标签并让其加载的方式是不可行的。 慎用这种方法，会对用户造成很糟糕的影响。</p>

<p><span style="font-weight:bold;color:green;font-size:18px;">&gt;&gt; 持续踩坑中&hellip;</span></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[css之border的拓展]]></title>
    <link href="http://senola.github.io/blog/2014/12/23/css-border/"/>
    <updated>2014-12-23T06:16:06+08:00</updated>
    <id>http://senola.github.io/blog/2014/12/23/css-border</id>
    <content type="html"><![CDATA[<p>关于css的border属性相信大家已经熟悉的不能再熟悉了。那么是不是这就意味border没有什么可以探究了呢？ <span style="font-style:italic;font-weight:bold;color:green;">now,let learn something that we never konew about!</span></p>

<p>我们知道CSS3可以很简单地创建圆角，而CSS2要实现圆角效果就复杂多了。在这些新技术未出现之前，我们可以通过使用绝对定位背景图片来显示圆或箭头，这就意味着需要另外的图片处理工具（如photoshop）配合使用。其实，如今显示圆或者圆角已不再需要其他背景图片了。<!--more--></p>

<h4><span style="font-style:italic;">1.The Basic</span></h4>

<p>可以经常看到border的一下用法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   border: 1px solid black;</span></code></pre></td></tr></table></div></figure>


<p>上面代码的意思为给元素加上一个1px的边框。这是border属性的简写方式，普通而又简单，我们也可以拆分如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   border-width: thick;   
</span><span class='line'>   border-style: solid;
</span><span class='line'>   border-color: black;</span></code></pre></td></tr></table></div></figure>


<p>border-width属性有了三个特殊值可供选择，分别是：thin，medium和thick。效果如下：</p>

<p><img src="https://raw.githubusercontent.com/senola/pictures/master/css/border/border-width.jpg" alt="border-image" /></p>

<p>看起来似乎将border属性分开来写不仅多余而且麻烦，但在某些特定的场合下还是很有用的，比如hover下改变边框的颜色，如果用简写的话还需要重复编写：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   .box {
</span><span class='line'>      border: 1px solid red;
</span><span class='line'>   }
</span><span class='line'>   .box:hover {
</span><span class='line'>      border: 1px solid green;
</span><span class='line'>   }</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>接用border-color属性的话依旧能达到同样的效果，而且这也是最合理的写法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   .box {
</span><span class='line'>      border: 1px solid red;
</span><span class='line'>   }
</span><span class='line'>   .box:hover {
</span><span class='line'>      border-color: green;
</span><span class='line'>   }</span></code></pre></td></tr></table></div></figure>


<h4><span style="font-style:italic;">2.border-radius</span></h4>

<p>border-radius 是CSS3提供的，并且是第一个被社区广泛使用的属性。IE8以上，所有现在浏览器都支持显示圆角。因为有了它，妈妈怎么也不担心我不会photoshop了~</p>

<p>显然，为了在各个浏览器中达到同样的效果，border-radius需要加上特定的前缀:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   -webkit-border-radius: 10px;
</span><span class='line'>      -moz-border-radius: 10px;
</span><span class='line'>           border-radius: 10px;</span></code></pre></td></tr></table></div></figure>


<p><img src="https://raw.githubusercontent.com/senola/pictures/master/css/border/border-radius.jpg" alt="border-radius.jpg" /></p>

<p>当然，我们也可以将它拆分成多个属性，自由的控制每一个角的显示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   border-top-left-radius: 20px;
</span><span class='line'>   border-top-right-radius: 0;
</span><span class='line'>   border-bottom-right-radius: 30px;
</span><span class='line'>   border-bottom-left-radius: 0;</span></code></pre></td></tr></table></div></figure>


<p><img src="https://raw.githubusercontent.com/senola/pictures/master/css/border/each-side.jpg" alt="each-side.jpg" /></p>

<p>事实上，上面代码设置<code>border-top-right-radius: 0</code>和<code>border-bottom-left-radius: 0;</code>属性是多余的，除非该属性会被继承时才需要重设。很显然border-radius不需要。</p>

<p>使用border-radius可以很简单的画一个柠檬：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   .lemon {
</span><span class='line'>       width: 200px; height: 200px; 
</span><span class='line'>     background: #F5F240;
</span><span class='line'>     border: 1px solid #F0D900;      
</span><span class='line'>     border-radius: 10px 150px 30px 150px;
</span><span class='line'>   }</span></code></pre></td></tr></table></div></figure>


<p><img src="https://raw.githubusercontent.com/senola/pictures/master/css/border/lemon.jpg" alt="lemon.jpg" /></p>

<p>额，是不是上面内容过于简单常见呢？我觉得也是，早就会了嘛。。接下来我们玩点新鲜的~</p>

<h4><span style="font-style:italic;">3. Multiple Borders</span></h4>

<p>当我们想把多重边框应用到一个元素上的时，有很多技术我们可以参考：</p>

<h5><span style="font-style:italic;color:red;">(1). border-style </span></h5>

<p>我们知道<code>solid</code>,<code>dashed</code>和<code>dotted</code>是<code>border-style</code>最常用的属性值。除了这些，我们还可以使用不常见的<code>groove</code>和<code>ridge</code>.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   border: 20px groove #e3e3e3;</span></code></pre></td></tr></table></div></figure>


<p>也可以拆分成如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   border-color: #e3e3e3;
</span><span class='line'>   border-width: 20px;
</span><span class='line'>   border-style: groove;</span></code></pre></td></tr></table></div></figure>


<p><img src="https://raw.githubusercontent.com/senola/pictures/master/css/border/groove-ridge.jpg" alt="groove-ridge.jpg" /></p>

<p>虽然这相当的有用，但是<code>ridge</code>或<code>groove</code>事实上都不是真正的多边框。</p>

<h5><span style="font-style:italic;color:red;">(2). outline </span></h5>

<p>目前，创建两个边框最流行的技术是使用<code>outline</code>属性。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   .box {
</span><span class='line'>      border: 5px solid #292929;
</span><span class='line'>      outline: 5px solid #e3e3e3;
</span><span class='line'>   }</span></code></pre></td></tr></table></div></figure>


<p><img src="https://raw.githubusercontent.com/senola/pictures/master/css/border/outline.jpg" alt="outline.jpg" /></p>

<p>这种方法运行效果棒，但是有一个限制就是只能创建两个边框。如果你需要创建一个有分层、带渐变效果时，得使用另外的方法。</p>

<h5><span style="font-style:italic;color:red;">(3). pseudo element (伪元素) </span></h5>

<p>当<code>outline</code>技术无法满足需要的时候，一种替代的方法是利用<code>:before</code>和<code>:after</code>伪元素，并且使用任何必要的额外边界生成的内容。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   .box {
</span><span class='line'>    position: relative;
</span><span class='line'>    width: 400px; 
</span><span class='line'>    height: 400px;
</span><span class='line'>    background: #e3e3e3;
</span><span class='line'>    border: 10px solid green;  
</span><span class='line'>  }
</span><span class='line'>   
</span><span class='line'>  /* Create two boxes with the same width of the container */
</span><span class='line'>  .box:after, .box:before {
</span><span class='line'>    content: '';
</span><span class='line'>    position: absolute;
</span><span class='line'>    top: 0; left: 0; bottom: 0; right: 0;
</span><span class='line'>  }
</span><span class='line'>   
</span><span class='line'>  .box:after {
</span><span class='line'>    border: 5px solid red;
</span><span class='line'>    outline: 5px solid yellow;
</span><span class='line'>  }
</span><span class='line'>   
</span><span class='line'>  .box:before {
</span><span class='line'>    border: 10px solid blue;
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p><img src="https://raw.githubusercontent.com/senola/pictures/master/css/border/pseudo-borders.jpg" alt="pseudo-borders.jpg" /></p>

<p>虽然这种方法不是最优雅的，但却也能达到预期效果。但也一点不理想就是颜色的顺序和边界颜色容易混淆。</p>

<h5><span style="font-style:italic;color:red;">(4). box-shadow </span></h5>

<p>最酷的且能创建无数边框的方法是利用<code>box-shadow</code>的<code>spread</code>参数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   .box {
</span><span class='line'>      border: 5px solid red;
</span><span class='line'>      box-shadow: 0 0 0 5px green,
</span><span class='line'>                  0 0 0 10px yellow,
</span><span class='line'>                  0 0 0 15px orange;
</span><span class='line'>   }</span></code></pre></td></tr></table></div></figure>




<div style="width: 400px; height: 400px;margin: 0 auto;margin-top: 25px;margin-bottom: 25px;background: #e3e3e3;border: 5px solid red;box-shadow: 0 0 0 5px green,0 0 0 10px yellow,0 0 0 15px orange;"></div>


<p>通过设置<code>box-shadow</code>的<code>x</code>,<code>y</code>,<code>blur</code>为0，我们可以使用<code>spread</code>值来创建边框，由于<code>box-shadow</code>可以对方，通过使用“，”就可以无限创建边框，是不是很有意思呢&hellip;(注意，老的浏览器并不识别该属性，不过作为现代人，就应该使用现代浏览器！！！)</p>

<h4><span style="font-style:italic;">4. modifying angles</span></h4>

<p>另外，我们可用使用“/”给<code>border-radius</code>赋值，定义唯一的水平和垂直半径：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   border-radius: 50px / 100px; /* horizontal radius, vertical radius */</span></code></pre></td></tr></table></div></figure>


<p>等价于：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   border-top-left-radius: 50px 100px;
</span><span class='line'>   border-top-right-radius: 50px 100px;
</span><span class='line'>   border-bottom-right-radius: 50px 100px;
</span><span class='line'>   border-bottom-left-radius: 50px 100px;</span></code></pre></td></tr></table></div></figure>


<p>这种技术是特别有用，当你需要模拟一个微妙的，冗长的曲线，而不是一个通用的圆角。例如,下面的代码允许我们稍微脱离一个正方形形状，就有卷纸一样的效果。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   .box {
</span><span class='line'>     width: 200px; 
</span><span class='line'>     height: 200px;
</span><span class='line'>     background: #666;
</span><span class='line'>     border-top-left-radius: 15em 1em;
</span><span class='line'>     border-bottom-right-radius: 15em 1em;
</span><span class='line'>   }</span></code></pre></td></tr></table></div></figure>


<div style="width: 200px; height: 200px; margin: 0 auto;background: #666; outline: lightgrey 1px solid;border-top-left-radius: 15em 1em;border-bottom-right-radius: 15em 1em;"></div>


<h4><span style="font-style:italic;">5. css shapes</span></h4>

<p>也许最赞的是将0宽度和0高度的边框运用于元素，很疑惑？哈&hellip;让我们看看示例：</p>

<p>下面几个例子都是用的同样的标记。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   &lt;div class="box"&gt;&lt;/div&gt;</span></code></pre></td></tr></table></div></figure>


<p>增加样式如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   .box {
</span><span class='line'>        width: 200px;
</span><span class='line'>        height: 200px;
</span><span class='line'>        background: black;
</span><span class='line'>   }</span></code></pre></td></tr></table></div></figure>


<p>最流行的演示例子是在项目中如何使用css创建箭头。理解它的核心思想，你会发现其实也就是那么回事。首先得为每一边设置背景颜色然后同时设置容器的<code>width</code>和<code>height</code>的值为0。</p>

<p>假设有一个<code>div</code>并且带有一个叫<code>arrow</code>的<code>class</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   .arrow {
</span><span class='line'>      width: 0;
</span><span class='line'>      height: 0;
</span><span class='line'>      border-top: 100px solid red;
</span><span class='line'>      border-right: 100px solid green;
</span><span class='line'>      border-bottom: 100px solid blue;
</span><span class='line'>      border-left: 100px solid yellow;
</span><span class='line'>   }</span></code></pre></td></tr></table></div></figure>


<p>同时你也可以这样简写：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   .arrow {
</span><span class='line'>      width: 0;
</span><span class='line'>      height: 0;
</span><span class='line'>      border: 100px solid;  
</span><span class='line'>      border-top-color: red;
</span><span class='line'>      border-right-color: green;
</span><span class='line'>      border-bottom-color: blue;
</span><span class='line'>      border-left-color: yellow;
</span><span class='line'>   }</span></code></pre></td></tr></table></div></figure>


<p>还一种更为炫酷的写法，相信你会喜欢：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   width: 0; height: 0;
</span><span class='line'>   border: 100px solid;
</span><span class='line'>   border-color: red green blue yellow;</span></code></pre></td></tr></table></div></figure>


<p><img src="https://raw.githubusercontent.com/senola/pictures/master/css/border/all-side-colors.jpg" alt="all-side-colors.jpg" /></p>

<p>是不是很有趣呢？赶紧试试吧！我们只需要设置容器的宽度和高度为0，在设置各个边的颜色，宽度就能达到效果。那么当我们把其中的三条边的颜色设置为透明又会是什么效果呢？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   .arrow {
</span><span class='line'>      width: 0; height: 0;
</span><span class='line'>      border: 100px solid;
</span><span class='line'>      border-bottom-color: blue;
</span><span class='line'>   }</span></code></pre></td></tr></table></div></figure>


<p><img src="https://raw.githubusercontent.com/senola/pictures/master/css/border/single-border.jpg" alt="single-border.jpg" /></p>

<p>哈&hellip;这是一个充满神奇的世界。不过，我们的探索可不是仅仅止步于此！如果用一个div来表示一个箭头，太语意话了。在实际运用中我们常常会使用伪元素创建类似气泡的样式。</p>

<h5><span style="font-style:italic;color:red;">(1). create a speech bubble</span></h5>

<p>我们可以用纯css创建一个类似气泡的对话。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   &lt;div class="speech-bubble"&gt;Hello world&lt;/div&gt;</span></code></pre></td></tr></table></div></figure>


<p>增加css样式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   .speech-bubble{
</span><span class='line'>      position: relative;
</span><span class='line'>      width: 200px;
</span><span class='line'>      height: 150px;
</span><span class='line'>      line-height: 150px; /* 垂直居中 */
</span><span class='line'>      color: white;
</span><span class='line'>      text-align: center;
</span><span class='line'>      background-color: #292929;
</span><span class='line'>      margin: 0 auto;
</span><span class='line'>      border-radius: 10px;
</span><span class='line'>   }
</span><span class='line'>   .speech-bubble:after { /*伪元素充当箭头*/
</span><span class='line'>      position: absolute;
</span><span class='line'>      content: '';
</span><span class='line'>      width: 0;
</span><span class='line'>      height: 0;
</span><span class='line'>      border: 10px solid;
</span><span class='line'>      border-top-color: #292929;
</span><span class='line'>      top: 100%;
</span><span class='line'>      left: 45%;
</span><span class='line'>   }</span></code></pre></td></tr></table></div></figure>


<p><img src="https://raw.githubusercontent.com/senola/pictures/master/css/border/final.jpg" alt="final.jpg" /></p>

<h5><span style="font-style:italic;color:red;">(2). 垂直居中</span></h5>

<p>如上，如果文字很多的话，设置line-height是效果不好的，可以将容器的display设置为table,在设置容器中的文字为vertical-align: middle</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   &lt;div class="speech-bubble speech-bubble-top"&gt;
</span><span class='line'>       &lt;p&gt;Text goes here.&lt;/p&gt;
</span><span class='line'>   &lt;/div&gt;</span></code></pre></td></tr></table></div></figure>


<p>css为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   .speech-bubble {
</span><span class='line'>    /* other styles */
</span><span class='line'>     display: table;
</span><span class='line'>   }
</span><span class='line'>    
</span><span class='line'>   .speech-bubble p {
</span><span class='line'>     display: table-cell;
</span><span class='line'>     vertical-align: middle;
</span><span class='line'>   }</span></code></pre></td></tr></table></div></figure>


<p>css是一个很神奇的东西，只要我们换个角度去思考就会有不一样的效果。附上两个例子：</p>

<div class="border-trans clearfix">
    <div class="border-hex-row">
        <div class="border-hex"><div class="border-top"></div><div class="border-middle"></div><div class="border-bottom"></div></div>
        <div class="border-hex"><div class="border-top"></div><div class="border-middle"></div><div class="border-bottom"></div></div>
        <div class="border-hex"><div class="border-top"></div><div class="border-middle"></div><div class="border-bottom"></div></div>
    </div>
    <div class="border-hex-row border-even">
        <div class="border-hex"><div class="border-top"></div><div class="border-middle"></div><div class="border-bottom"></div></div>
        <div class="border-hex"><div class="border-top"></div><div class="border-middle"></div><div class="border-bottom"></div></div>
    </div>
    <div class="border-hex-row">
        <div class="border-hex"><div class="border-top"></div><div class="border-middle"></div><div class="border-bottom"></div></div>
        <div class="border-hex"><div class="border-top"></div><div class="border-middle"></div><div class="border-bottom"></div></div>
        <div class="border-hex"><div class="border-top"></div><div class="border-middle"></div><div class="border-bottom"></div></div>
    </div>
</div>


<div class="border-biohazard"></div>


<p></p>

<h4><span style="font-style:italic;clear:both;">总结</span></h4>

<p>css 是一个很神奇的东西好好努力！！！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTML head 头标签]]></title>
    <link href="http://senola.github.io/blog/2014/11/13/head-tag/"/>
    <updated>2014-11-13T04:41:47+08:00</updated>
    <id>http://senola.github.io/blog/2014/11/13/head-tag</id>
    <content type="html"><![CDATA[<p>HTML(TyperText Markup language)的<code>head</code>标签、元素有很多，涉及到浏览器对网页的渲染，SEO等。移动互联网时代，<code>head</code>头部结构、移动端的<code>meta</code>元素显得更为重要。</p>

<h3>1. DOCTYPE</h3>

<p>DOCTYPE(Document Type),该声明位于文档中最前面位置，处于<code>html</code>标签之前。告知浏览器文档使用哪种<code>Html</code>或者<code>XHTML</code>规范。</p>

<p>DTD (Document Type Definition)声明以<code>&lt;!--DOCTYPE--&gt;</code>开始，不区分大小写，前面没有任何内容。如果有其他内容（除空格外）会使浏览器在<code>IE</code>下开启<code>quirks mode</code>模式来渲染完网页。公共<code>DTD</code>，名称格式为注册//组织//类型 标签//语言,注册指组织是否由国际标准化组织(ISO)注册，+表示是，-表示不是。组织即组织名称，如：W3C。类型一般是 DTD。标签是指定公开文本描述，即对所引用的公开文本的唯一描述性名称，后面可附带版本号。最后语言是 DTD 语言的 ISO 639 语言标识符，如：EN 表示英文，ZH 表示中文。XHTML 1.0 可声明三种 DTD 类型。分别表示严格版本，过渡版本，以及基于框架的 HTML 文档。</p>

<!--more-->


<ul>
<li><p>HTML 4.01 strict(严格版本)</p>

<pre><code> &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;
</code></pre></li>
<li><p>HTML 4.01 Transition(过度版本)</p>

<pre><code> &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;    
</code></pre></li>
<li><p>HTML4.01 frameset(框架)</p>

<pre><code> &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd"&gt; 
</code></pre></li>
<li><p>最新<code>HTML5</code>退出更加简洁的书写，它向前先后兼容，推荐使用。</p>

<pre><code> &lt;!doctype html&gt;  
</code></pre></li>
</ul>


<p>在<code>HTML</code>中，<code>doctype</code>有两个主要的目的：</p>

<ul>
<li> 对文档进行有效性验证</li>
<li> 决定浏览器的呈现模式</li>
</ul>


<p>对于实际操作，通知浏览器读取文档时用哪种解析算法。如果没有写，则浏览器根据自身的规则对代码进行解析。可能会严重影响<code>HTML</code>排版布局。浏览器有三种花方式解析<code>HTML</code>文档。</p>

<ul>
<li>标准模式（费怪异模式）</li>
<li>怪异模式</li>
<li>部分怪异（近乎标准）模式</li>
</ul>


<h3>2. charset</h3>

<p>声明文档的字符编码：</p>

<pre><code> &lt;meta charset="utf-8"&gt;
</code></pre>

<p>html5 之前网页中会这样写：</p>

<pre><code> &lt;meta http-equiv="Content-Type" content="text/html;charset=utf-8"&gt;
</code></pre>

<p>这两种写法是等效的，具体可点击<a href="http://stackoverflow.com/questions/4696499/meta-charset-utf-8-vs-meta-http-equiv-content-type" target="_blank" style="font-size:15px;color:green;font-weight:bold;"> Click Me !!</a></p>

<h3>3. lang属性</h3>

<p>简体中文</p>

<pre><code>&lt;html lang="zh-cmn-Hans"&gt;
</code></pre>

<p>繁体中文</p>

<pre><code>&lt;html lang="zh-cmn-Hant"&gt; 
</code></pre>

<p>更多请猛戳 <a href="http://www.zhihu.com/question/20797118?utm_source=weibo&utm_medium=weibo_share&utm_content=share_question&utm_campaign=share_sidebar" target="_blank" style="font-size:15px;color:green;font-weight:bold;"> Click Me !!</a></p>

<h3>4. 优先使用IE最新版本和Chrome</h3>

<pre><code>&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt;
</code></pre>

<h3>5. 360浏览器使用 Google Chrome Frame</h3>

<pre><code>&lt;meta name="renderer" content="webkit"&gt; 
</code></pre>

<p>360 浏览器就会在读到这个标签后，立即切换对应的急速核。另外，为了保险起见再加入：</p>

<pre><code>&lt;meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"&gt;
</code></pre>

<p>这样写可以达到的效果是如果安装了 <code>Google Chrome Frame</code>,则使用<code>GCF</code>来渲染页面，如果没有，则使用最高版本的<code>IE</code>内核进行渲染。具体可阅读360文档<a href="http://se.360.cn/v6/help/meta.html" target="_blank" style="font-size:15px;color:green;font-weight:bold;"> Click Me !!</a></p>

<h3>6. 百度禁止转码</h3>

<p>通过百度手机打开网页时，百度可能会对你的网页进行转码。扒下你的衣服，往你身上贴广告，为此可以在<code>head</code>内添加：</p>

<pre><code>&lt;meta http-equiv="Cache-Control" content="no-siteapp" /&gt;
</code></pre>

<h3>7. SEO优化部分</h3>

<ul>
<li><p>页面标题<code>&lt;title&gt;</code>标签</p>

<pre><code>  &lt;title&gt; my title&lt;/title&gt; 
</code></pre></li>
<li><p>页面关键词 <code>keywords</code></p>

<pre><code>  &lt;meta name="keywords" content="your keywords"&gt; 
</code></pre></li>
<li><p>页面描述内容<code>description</code></p>

<pre><code> &lt;meta name="description" content="your description"&gt;
</code></pre></li>
<li><p>定义网页作者<code>author</code></p>

<pre><code> &lt;meta name="author" content="author,email,address"&gt;
</code></pre></li>
<li><p>定义网页搜索引擎索引方式。<code>robotterms</code>是一组使用英文逗号[,]分割的值，通常有如下几种取值：<code>none</code>、<code>noindex</code>、<code>nofollow</code>、<code>all</code>、<code>index</code>和<code>follow</code>。</p>

<pre><code> &lt;meta name="robots" content="index.follow"&gt;
</code></pre></li>
</ul>


<h3>8. viewport</h3>

<p>viewport 可以让布局在移动浏览器上显示的更好，通常会写：</p>

<pre><code> &lt;meta name="viewport" content="width=device-width,initial-scale=1.0"&gt;
</code></pre>

<p><code>width=device-width</code>会导致<code>iphone 5</code>添加到主屏幕后以<code>webApp</code>全屏幕模式打开页面时出现黑边。</p>

<p>conten参数：</p>

<ul>
<li>width: viewport 宽度（数值/device-width）</li>
<li>height: viewport 高度（数值/device-height）</li>
<li>initial-scale： 初始缩放比例</li>
<li>minimum-scale: 最大缩放比例</li>
<li>minimum-scale: 最小缩放比例</li>
<li>user-scalable: 是否允许用户缩放（yes/no）</li>
<li><p>minimal-ui iOS 7.1 beta2 中新增属性，可以再页面加载时最小化上下状态栏。这是一个布尔值，可以直接这样写：</p>

<pre><code>  &lt;meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui"&gt;
</code></pre></li>
</ul>


<p>而如果你的网站不是响应式的请不要使用<code>initial-scale</code>或者禁用缩放。</p>

<pre><code>  &lt;meta name="viewport" content="width=device-width,user-scalable=yes"&gt;
</code></pre>

<p>适配<code>iphone 6</code>和 <code>iphone 6plus</code>则需要写：</p>

<pre><code> &lt;meta name="viewport" content="width=375"&gt;    
 &lt;meta name="viewport" content="width=414"&gt;
</code></pre>

<p>大部分 4.7~5 寸的安卓设备的 viewport 宽设为 360px，iPhone 6 上却是 375px，大部分 5.5 寸安卓机器（比如说三星 Note）的 viewport 宽为 400，iPhone 6 plus 上是 414px。</p>

<h3>9. ios 设备</h3>

<p>添加到主屏后的标题（iOS6 新增）</p>

<pre><code>&lt;meta name="apple-mobile-web-app-title" content="标题"&gt; &lt;!-- 添加到主屏后的标题（iOS 6 新增） --&gt;
</code></pre>

<p>是否启用<code>webApp</code>全屏模式</p>

<pre><code>&lt;meta name="apple-mobile-web-app-capable" content="yes" /&gt; &lt;!-- 是否启用 WebApp 全屏模式 --&gt;
</code></pre>

<p>设置状态栏的背景色</p>

<pre><code>&lt;meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" /&gt; &lt;!-- 设置状态栏的背景颜色，只有在 `"apple-mobile-web-app-capable" content="yes"` 时生效 --&gt;
</code></pre>

<p>只有在 &ldquo;apple-mobile-web-app-capable&rdquo; content=&ldquo;yes&rdquo; 时生效</p>

<p>content 参数：</p>

<ul>
<li>default 默认值。</li>
<li>black 状态栏背景是黑色。</li>
<li>black-translucent 状态栏背景是黑色半透明。 如果设置为 default 或 black ,网页内容从状态栏底部开始。 如果设置为 black-translucent ,网页内容充满整个屏幕，顶部会被状态栏遮挡。</li>
</ul>


<p>禁止数字自动识别为电话号码：</p>

<pre><code> &lt;meta name="format-detection" content="telephone=no" /&gt; &lt;!-- 禁止数字自动识别为电话号码 --&gt;
</code></pre>

<h3>10. ios图标</h3>

<p>rel 参数： apple-touch-icon 图片自动处理成圆角和高光等效果。 apple-touch-icon-precomposed 禁止系统自动添加效果，直接显示设计原图。 iPhone 和 iTouch，默认 57x57 像素，必须有：</p>

<pre><code>&lt;link rel="apple-touch-icon-precomposed" href="http://senola.github.io/apple-touch-icon-57x57-precomposed.png" /&gt; &lt;!-- iPhone 和 iTouch，默认 57x57 像素，必须有 --&gt;
</code></pre>

<p>iPad，72x72 像素，可以没有，但推荐有：</p>

<pre><code>&lt;link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://senola.github.io/apple-touch-icon-72x72-precomposed.png" /&gt; &lt;!-- iPad，72x72 像素，可以没有，但推荐有 --&gt;
</code></pre>

<p>Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有：</p>

<pre><code>&lt;link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://senola.github.io/apple-touch-icon-114x114-precomposed.png" /&gt; &lt;!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 --&gt;
</code></pre>

<p>Retina iPad，144x144 像素，可以没有，但推荐有：</p>

<pre><code>&lt;link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://senola.github.io/apple-touch-icon-144x144-precomposed.png" /&gt; &lt;!-- Retina iPad，144x144 像素，可以没有，但推荐有 --&gt;
</code></pre>

<p>IOS 图标大小在iPhone 6 plus上是180×180，iPhone 6 是120x120。 适配iPhone 6 plus，则需要在中加上这段：</p>

<pre><code>&lt;link rel="apple-touch-icon-precomposed" sizes="180x180" href="retinahd_icon.png"&gt;
</code></pre>

<h3>11.ios启动画面</h3>

<p>官方文档：<a href="https://developer.apple.com/library/ios/qa/qa1686/_index.html" target="_blank" style="font-size:15px;color:green;font-weight:bold;"> <a href="https://developer.apple.com/library/ios/qa/qa1686/_index.html">https://developer.apple.com/library/ios/qa/qa1686/_index.html</a></a>
 参考文章：<a href="http://wxd.ctrip.com/blog/2013/09/ios7-hig-24/" target="_blank" style="font-size:15px;color:green;font-weight:bold;"> <a href="http://wxd.ctrip.com/blog/2013/09/ios7-hig-24/">http://wxd.ctrip.com/blog/2013/09/ios7-hig-24/</a></a></p>

<p>iPad 的启动画面是不包括状态栏区域的。
iPad 竖屏 768 x 1004（标准分辨率）:</p>

<pre><code>  &lt;link rel="apple-touch-startup-image" sizes="768x1004" href="http://senola.github.io/splash-screen-768x1004.png" /&gt; &lt;!-- iPad 竖屏 768 x 1004（标准分辨率） --&gt;
</code></pre>

<p>iPad 竖屏 1536x2008（Retina）:</p>

<pre><code>  &lt;link rel="apple-touch-startup-image" sizes="1536x2008" href="http://senola.github.io/splash-screen-1536x2008.png" /&gt; &lt;!-- iPad 竖屏 1536x2008（Retina） --&gt;
</code></pre>

<p>iPad 横屏 1024x748（标准分辨率）:</p>

<pre><code>  &lt;link rel="apple-touch-startup-image" sizes="1024x748" href="http://senola.github.io/Default-Portrait-1024x748.png" /&gt; &lt;!-- iPad 横屏 1024x748（标准分辨率） --&gt;
</code></pre>

<p>iPad 横屏 2048x1496（Retina）:</p>

<pre><code> &lt;link rel="apple-touch-startup-image" sizes="2048x1496" href="http://senola.github.io/splash-screen-2048x1496.png" /&gt; &lt;!-- iPad 横屏 2048x1496（Retina） --&gt;
</code></pre>

<p>iPhone 和 iPod touch 的启动画面是包含状态栏区域的。</p>

<p>iPhone/iPod Touch 竖屏 320x480 (标准分辨率):</p>

<pre><code> &lt;link rel="apple-touch-startup-image" href="http://senola.github.io/splash-screen-320x480.png" /&gt; &lt;!-- iPhone/iPod Touch 竖屏 320x480 (标准分辨率) --&gt;
</code></pre>

<p>iPhone/iPod Touch 竖屏 640x960 (Retina):</p>

<pre><code>&lt;link rel="apple-touch-startup-image" sizes="640x960" href="http://senola.github.io/splash-screen-640x960.png" /&gt; &lt;!-- iPhone/iPod Touch 竖屏 640x960 (Retina) --&gt;
</code></pre>

<p>iPhone 5/iPod Touch 5 竖屏 640x1136 (Retina):</p>

<pre><code>&lt;link rel="apple-touch-startup-image" sizes="640x1136" href="http://senola.github.io/splash-screen-640x1136.png" /&gt; &lt;!-- iPhone 5/iPod Touch 5 竖屏 640x1136 (Retina) --&gt;
</code></pre>

<p>添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）:</p>

<pre><code>&lt;meta name="apple-itunes-app" content="app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL"&gt; &lt;!-- 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari） --&gt;
</code></pre>

<p>iPhone 6对应的图片大小是750×1294，iPhone 6 Plus 对应的是1242×2148 :</p>

<pre><code> &lt;link rel="apple-touch-startup-image" href="launch6.png" media="(device-width: 375px)"&gt;
 &lt;link rel="apple-touch-startup-image" href="launch6plus.png" media="(device-width: 414px)"&gt;
</code></pre>

<h3>12. window 8</h3>

<p>Windows 8 磁贴颜色:</p>

<pre><code>&lt;meta name="msapplication-TileColor" content="#000"/&gt; &lt;!-- Windows 8 磁贴颜色 --&gt; 
</code></pre>

<p>Windows 8 磁贴图标</p>

<pre><code>&lt;meta name="msapplication-TileImage" content="icon.png"/&gt; &lt;!-- Windows 8 磁贴图标 --&gt;
</code></pre>

<h3>13 rss 订阅</h3>

<pre><code>&lt;link rel="alternate" type="application/rss+xml" title="RSS" href="http://senola.github.io/rss.xml" /&gt; &lt;!-- 添加 RSS 订阅 --&gt;
</code></pre>

<h3>14.favicon icon</h3>

<pre><code>&lt;link rel="shortcut icon" type="image/ico" href="http://senola.github.io/favicon.ico" /&gt; &lt;!-- 添加 favicon icon --&gt;
</code></pre>

<p>比较详细的 favicon 介绍可参考<a href="https://github.com/audreyr/favicon-cheat-sheet" target="_blank" style="font-size:15px;color:green;font-weight:bold;"><a href="https://github.com/audreyr/favicon-cheat-sheet">https://github.com/audreyr/favicon-cheat-sheet</a></a></p>

<h3>15.移动端的meta</h3>

<pre><code>&lt;meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" /&gt;
&lt;meta name="apple-mobile-web-app-capable" content="yes" /&gt;
&lt;meta name="apple-mobile-web-app-status-bar-style" content="black" /&gt;
&lt;meta name="format-detection"content="telephone=no, email=no" /&gt;
&lt;meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" /&gt;
&lt;!-- 删除苹果默认的工具栏和菜单栏 --&gt;
&lt;meta name="apple-mobile-web-app-capable" content="yes" /&gt;
&lt;!-- 设置苹果工具栏颜色 --&gt;
&lt;meta name="apple-mobile-web-app-status-bar-style" content="black" /&gt;
&lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt;
&lt;meta name="format-detection" content="telphone=no, email=no" /&gt;
&lt;!-- 启用360浏览器的极速模式(webkit) --&gt;
&lt;meta name="renderer" content="webkit"&gt;
&lt;!-- 避免IE使用兼容模式 --&gt;
&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;
&lt;meta name="HandheldFriendly" content="true"&gt;
&lt;!-- 微软的老式浏览器 --&gt;
&lt;meta name="MobileOptimized" content="320"&gt;
&lt;!-- uc强制竖屏 --&gt;
&lt;meta name="screen-orientation" content="portrait"&gt;
&lt;!-- QQ强制竖屏 --&gt;
&lt;meta name="x5-orientation" content="portrait"&gt;
&lt;!-- UC强制全屏 --&gt;
&lt;meta name="full-screen" content="yes"&gt;
&lt;!-- QQ强制全屏 --&gt;
&lt;meta name="x5-fullscreen" content="true"&gt;
&lt;!-- UC应用模式 --&gt;
&lt;meta name="browsermode" content="application"&gt;
&lt;!-- QQ应用模式 --&gt;
&lt;meta name="x5-page-mode" content="app"&gt;
&lt;!-- windows phone 点击无高光 --&gt;
&lt;meta name="msapplication-tap-highlight" content="no"&gt;
&lt;!-- 适应移动端end --&gt;   
</code></pre>

<p>参考文章：</p>

<ul>
<li><a href="https://github.com/yisibl/blog/issues/1" target="_blank" style="font-size:15px;color:green;font-weight:bold;">常用的 HTML 头部标签</a></li>
<li><a href="https://gist.github.com/paddingme/6182708733917ae36331" target="_blank" style="font-size:15px;color:green;font-weight:bold;">html5_header</a></li>
<li><a href="http://amazeui.org/css/" target="_blank" style="font-size:15px;color:green;font-weight:bold;">amazeui css</a></li>
<li><a href="http://www.douban.com/note/170560091/" target="_blank" style="font-size:15px;color:green;font-weight:bold;">DOCTYPE</a></li>
<li><a href="http://www.uisdc.com/ios8-ten-new-feature" target="_blank" style="font-size:15px;color:green;font-weight:bold;">WEB 工程师和设计师必学的 10 个 IOS 8 新鲜改变</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浏览器到底是咋工作的？]]></title>
    <link href="http://senola.github.io/blog/2014/10/27/how-browsers-work/"/>
    <updated>2014-10-27T23:17:27+08:00</updated>
    <id>http://senola.github.io/blog/2014/10/27/how-browsers-work</id>
    <content type="html"><![CDATA[<h3>一、前言</h3>

<p>最近工作找的很是捉急，各种碰壁<code>Zz~(～ o ～)~zZ</code>。哎，说到头还是自己知识储备少，不深入。去一家公司面试前端，被问得是哑口无言，“说说浏览器是怎么渲染的？”、“如果要你用原生JS去解析JSON你会怎么做？”、“有自己的JS库吗？”。。。我<code>TM</code>怎么知道浏览器是如何渲染的，TM这是多高端的东西。劳资也只是刚出道一年，也就会写写页面、改改样式。<code>TM</code>我怎么知道如何去写原生的<code>JSON</code>解析，<code>javascript</code>不是有封装好的<code>JSON</code>解析<code>API</code>,鬼才会去想怎么实现啊，就面试那几分钟你能给个方案？。<!--more--><code>TM</code>我就不信我不会这些会影响工作。。</p>

<p>很牢骚是吗？一点也不。程序猿不经常牢骚那该会多么无趣啊！不过呢牢骚完了咱还得回头整整不是。没办法，谁叫咱菜啥也不会呢，要我是大牛我一定给你整趴下（<code>TM</code>当场就拒绝我，不会委婉点啊！没品，迟早出门掉钱..）。不过话说回来，我也很想知道像我们这群码农必定整天都要打交道的浏览器到底是咋工作？有什么深奥的<code>Knowledge</code>？</p>

<h3>二、How browsers work</h3>

<p>外国人的东西当然他们更懂，特别欣赏他们那种<code>Open</code>、<code>Share</code>和<code>Free</code>的理念，不像国人XX@#@#@#$$。<a href="http://taligarsiel.com/Projects/howbrowserswork1.htm" target="_blank" style="color:green;font-weight:bold;font-size:16px;font-style:italic;">How browsers work</a> &mdash;-这个文章介绍了浏览器从头到尾的工作机制，如：HTML的解析、DOM树的生成、CSS的渲染等。为了拓展一下视野，不再被人鄙视，GO！！！</p>

<h4>2.1 浏览器是做啥的？</h4>

<p>当今地球主流浏览器有五类：IE（Internet Explorer）、Firefox、Safari、Chrome和Opera.那么它们是用来做什么呢？还用讲，当然是用来上网的呗，谁的速度快我就用谁~</p>

<p>浏览器的主要功能是展示网页资源，即用户请求<code>url</code>后将结果显示在浏览器窗口。可以展示包括<code>Html</code>、<code>PDF</code>、<code>picture</code>和文字等。</p>

<h4>2.2 浏览器的上层结构</h4>

<p>浏览器的主要歹念如下：</p>

<ul>
<li>用户接口：包括地址栏、前进、后退、书签菜单等窗口上出了网页显示区域以外的部分。</li>
<li>浏览器引擎： 查询与操作渲染引擎的接口</li>
<li>渲染引擎： 负责显示请求的内容。比如请求到<code>HTML</code>，它会负责解析<code>HTML</code>与<code>CSS</code>并将结果显示到窗口中。</li>
<li>网络：用于网路请求。如<code>http</code>请求。</li>
<li><code>UI</code>后端： 回执基础元件。如组合框与窗口。</li>
<li><code>Javascript</code>解析器： 用于解析执行<code>Javascript</code>代码。</li>
<li>数据存储：这是一个持久层。浏览器需要把所有数据存到硬盘上。如：cookies.<code>HTML5</code>规定了一个完整的浏览器中的数据库：“web database”。</li>
</ul>


<p><img src="https://raw.githubusercontent.com/senola/pictures/master/how_browsers_work/how_browsers_work_layers.png" alt="layers" /><br/>
图1 浏览器的主要概念</p>

<p>note： 与其他浏览器不同，<code>chrome</code>使用多个渲染引擎实例，每个<code>TAB</code>都是一个独立的进程。</p>

<h4>2.3 渲染引擎</h4>

<p>关于渲染引擎，<code>FireFox</code>使用<code>Gecko</code>； <code>Mozilla</code>用自家的渲染引擎；<code>Safari</code>和<code>chrome</code>都使用<code>Webkit</code>.</p>

<p><code>Webkit</code>是一个开源的渲染引擎，它源自<code>Linux</code>平台，经过<code>Apple</code>公司的修改可以支持<code>Mac</code>与<code>Window</code>平台。<a href="http://webkit.org" target="_bliank"><a href="http://webkit.org">http://webkit.org</a></a></p>

<h4>2.4 The main flow</h4>

<p>渲染引擎开始于从网络层获取请求内容，一般是不超过8K的数据块。接下来就是渲染引擎的基本工作流程：</p>

<p><img src="https://raw.githubusercontent.com/senola/pictures/master/how_browsers_work/how_browsers_work_flow.png" alt="flow" /><br/>
图 2：渲染引擎的基本工作流程</p>

<p>基本工作流分别是：解析<code>Html</code>、构建<code>DOM</code>树、渲染树结构、渲染树布局、绘制渲染树。渲染引擎会解析<code>HTML</code>文档并把标签转换成内容树中的<code>DOM</code>节点。它会解析<code>style</code>元素和外部文件中的样式数据，样式数据和<code>Html</code>中的现实控制将共同用来创建另一棵树&mdash;渲染树。</p>

<p>渲染树包含带有颜色、尺寸等显示属性的矩形。这些矩形的顺序与显示顺序一致。渲染树构建完成后就是“布局”处理，也就是确定每个节点在屏幕上的确切显示位置。下一步骤是“绘制”&mdash;&mdash;遍历渲染树并用<code>UI</code>后端层将每一个节点绘制出来。为了更好的用户体验，渲染引擎会尝试尽快的把内容显示出来。它不会等到所有ＨＴＭＬ都被解析完才创建并布局渲染树。它会 在处理后续内容的同时把处理过的局部内容先展示出来。</p>

<p><img src="https://raw.githubusercontent.com/senola/pictures/master/how_browsers_work/how_browsers_work_geckoflow.jpg" alt="geckoflow" /><br/>
图3： Webkit主要流程</p>

<p><img src="https://raw.githubusercontent.com/senola/pictures/master/how_browsers_work/how_browsers_work_webkitflow.png" alt="webkitflow" /><br/>
图4： Mozilla的Gecko渲染引擎主要流程</p>

<p>从上图可以看出，尽管<code>Webkit</code>与<code>Gecko</code>使用略微不同的术语，这个过程还是基本相同的。<code>Gecko</code> 里把格式化好的可视元素称做“帧树”（Frame tree）。每个元素就是一个帧（frame）。 <code>Webkit</code> 则使用”渲染树”这个术语，渲染树由”渲染对象”组成。Webkit 里使用”layout”表示元素的布局，<code>Gecko</code>则称为”Reflow”。<code>Webkit</code>使用”Attachment”来连接DOM节点与可视化信息以构建渲染树。一个非语义上的小差别是<code>Gecko</code>在<code>Html</code>与<code>Dom</code>树之间有一个附加的层 ，称作”content sink”，是创建<code>Dom</code>对象的工厂。</p>

<h4>2.5 Parsing (解析)</h4>

<p>解析一个文档意味着把它翻译成有意义的结构以供代码使用。解析的结果通常是一个由文档组成的树，称之为解析树或者语法树。示例&mdash;&mdash;解析表达式“2 + 3 &ndash; 1” 可以返回下面树：</p>

<p><img src="https://raw.githubusercontent.com/senola/pictures/master/how_browsers_work/how_browsers_work_nodetree.png" alt="nodetree" /> <br/>
图5：表达式树节点</p>

<h4>2.6 Grammars（语法）</h4>

<p>解析是基于文档所遵循的语法规则&mdash;&mdash;书写所用的语言或格式来进行的。每一种可以解析的格式必须由确定的语法与词汇组成。这被称之为上下文无关语法。人类语言并非此种语言，所以不能用常规的解析技术来解析。</p>

<h4>2.7 Parser &ndash; Lexer combination （解析器&mdash;词法分析组合）</h4>

<p>解析器有两个处理过程:词法分析与句法分析。词法分析负责把输入切分成符号序列，符号是语言的词汇——由该语言所有合法的单词组成。句法分析是对该语言句法法则的应用。解析器通常把工作分给两个组件——分词程序负责把输入切分成合法符号序列，解析程序负责按照句法规则分析文档结构和构建句法树。词法分析器知道如何过滤像空格，换行之类的无关字符。</p>

<p><img src="https://raw.githubusercontent.com/senola/pictures/master/how_browsers_work/how_browsers_work_parsetree.png" alt="parsetree" /> <br/>
图6： 从源文档到解析树（文档、词法分析、语法分析、解析树）</p>

<p>解析过程是交互式的。解析器通常会从词法分析器获取新符号并尝试匹配句法规则。如果匹配成功，就在句法树上创建相应的节点，并继续从词法分析器获取下一个符号。如果没有匹配的规则，解析器会内部保存这个符号，并继续从词法分析器获取符号，直到内部保存的所有符号能够成功匹配一个规则。如果最终无法匹配，解析器会抛出异常。这意味着文档无效，含有句法错误。</p>

<h4>2.8 Translation（转换）</h4>

<p>多数情况下解析树并非最终结果。解析经常是为了从输入文档转换成另外一种格式。比如编译器要把源码编译成机器码，会首先解析成解析树，再把解析树转换成机器码。</p>

<p><img src="https://raw.githubusercontent.com/senola/pictures/master/how_browsers_work/how_browsers_work_compilationflow.png" alt="compilationflow" />  <br/>
图7：编译过程（源码、解析、解析树、转换、机器码）</p>

<h4>2.9 HTML DTD</h4>

<p><code>HTML</code>的定义使用<code>DTD</code>文件。这种格式用来定义<code>SGML(Standard Generalized Markup language)</code>标准通用标记语言族语言，它包含对所有允许的元素的定义，包括它们的属性和层级关系。如我们前面所说，<code>HTML DTD</code>构不成上下文无关语法。</p>

<p><code>DTD</code>有几种不同类型。严格模式完全尊守规范，但其它模式为了向前兼容可能包含对早期浏览器所用标签的支持。当前的严格模式<code>DTD</code>：<a href="http://www.w3.org/TR/html4/strict.dtd">http://www.w3.org/TR/html4/strict.dtd</a></p>

<h4>2.10 DOM</h4>

<p>解析器输出的树是由<code>DOM</code>元素和属性节点组成的。<code>DOM</code>的全称为：<code>Document Object Model</code>。它是<code>HTML</code>文档的对象化描述，也是<code>HTML</code>元素与外界（如<code>Javascript</code>）的接口。<code>DOM</code>与标签几乎有着一一对应的关系，如下面的标签</p>

<pre><code>&lt;html&gt;
    &lt;body&gt;
        &lt;p&gt;
            Hello World
        &lt;/p&gt;
        &lt;div&gt; &lt;img src="example.png"/&gt;&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>会被转换成如的<code>DOM</code>树：</p>

<p><img src="https://raw.githubusercontent.com/senola/pictures/master/how_browsers_work/how_browsers_work_domtree.png" alt="domtree" /> <br/>
图8： DOM tree of the example markup</p>

<p>与<code>HTML</code>一样，<code>DOM</code>规范也由<code>w3c</code>组织制订。参考：<a href="http://www.w3.org/DOM/DOMTR">http://www.w3.org/DOM/DOMTR</a>. 这是一个操作文档的通用规范。有一个专门的模块定义HTML特有元素: <a href="http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html">http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html</a>.</p>

<p>当我们说树中包含<code>DOM</code>节点时，意思就是这个树是由实现了<code>DOM</code>接口的元素组成。这些实现包含了其它一些浏览器内部所需的属性。</p>

<h4>2.11 The parsing algorithm(解析算法)</h4>

<p>如我们前面看到的，<code>HTML</code>无法使用自上而下或自下而上的解析器来解析。
原因如下：</p>

<ul>
<li>语言的宽容特点</li>
<li>浏览器需要对无效<code>HTML</code>提供容错的事实</li>
<li>解析过程的反复。通常解析过程中源码不会变化。但在<code>HTML</code>中，<code>script</code>标签包含<code>document.write</code>时可以添加内容，即解析过程实际上还会改变源码。</li>
</ul>


<p>浏览器创建了自己的解析器来解析HTML文档。<code>HTML5</code>规范里对解析算法有具体的说明，解析由两部分组成：分词与构建树。分词属于词法分析部分，它把输入解析成符号序列。在<code>HTML</code>中符号就是开始标签，结束标签，属性名称和属生值。分词器识别这些符号并将其送入树构建者，然后继续分析处理下一个符号，直到输入结束。</p>

<p><img src="https://raw.githubusercontent.com/senola/pictures/master/how_browsers_work/how_browsers_work_html_parsing_flow.png" alt="how_browsers_work_html_parsing_flow" />  <br/>
图9： HTML解析流程 (源自HTML5规范)</p>

<p>暂时只了解这么多了，有空再学习学习~ 这里还有两篇 <a href="http://coolshell.cn/articles/9666.html" style="color:green;font-weight:bold;font-style:italic;font-size:16px" target="_blank">&lt;&lt;浏览器的渲染原理简介&gt;&gt;</a>、<a href="http://www.nowamagic.net/academy/detail/48110160" style="color:green;font-weight:bold;font-style:italic;font-size:16px" target="_blank">&lt;&lt;浏览器加载和渲染HTML的顺序以及Gzip的问题&gt;&gt;</a> 文章，得抽空观摩观摩！！！</p>

<p><strong>参考资料</strong>：</p>

<ul>
<li><a href="http://taligarsiel.com/Projects/howbrowserswork1.htm">http://taligarsiel.com/Projects/howbrowserswork1.htm</a></li>
<li><a href="http://ued.ctrip.com/blog/?p=3295">http://ued.ctrip.com/blog/?p=3295</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈javascript 中undefined、null 和 NaN，call()和apply()的区别]]></title>
    <link href="http://senola.github.io/blog/2014/09/13/javascript-study-140912/"/>
    <updated>2014-09-13T02:34:12+08:00</updated>
    <id>http://senola.github.io/blog/2014/09/13/javascript-study-140912</id>
    <content type="html"><![CDATA[<h3>一、undefined、null 和 NaN</h3>

<h4>1.类型区别</h4>

<p><code>javascript</code>中有5中简单的数据类型（也称为基本数据类型），分别是：<code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>number</code>和<code>String</code>。另外还有一种复杂数据类型&mdash;&ndash;<code>objecct</code>,<code>object</code>本质上是由一组无序的名值对组成。 <br/>
介于<code>javascript</code>是松散类型的，因此需要有一种手段来检测给定的数据类型&mdash;<code>typeof</code>。对于一个值使用<code>typeof</code>操作符后可能返回下列某个字符串：</p>

<ul>
<li>&ldquo;undefined&rdquo;: 值未定义</li>
<li>&ldquo;boolean&rdquo;: 值为布尔值</li>
<li>&ldquo;string&rdquo;: 值为字符串</li>
<li>&ldquo;number&rdquo;: 值为数值</li>
<li>&ldquo;object&rdquo;: 值为对象或者null</li>
<li>&ldquo;function&rdquo;: 值为函数
<!--more--></li>
</ul>


<p> 测试代码：</p>

<pre><code>   var s1;      
   var s2 = true;   
   var s3 = 1;  
   var s4 = "javascript";  
   var s5 = new Object();  
   var s6 = null;
   var s7 = NaN;  
   var s8 = undefined;  
   var s9 = function () {}; 

   alert(typeof s1); //显示"undefined"  
   alert(typeof s2); //显示"boolean"  
   alert(typeof s3); //显示"number"   
   alert(typeof s4); //显示"string"   
   alert(typeof s5); //显示"object"   
   alert(typeof s6); //显示"object"   
   alert(typeof s7); //显示"number"   
   alert(typeof s8); //显示"undefined"   
   alert(typeof s9);  //显示"function"     
</code></pre>

<p>从以上代码可以看出未定义的和定义未赋值的类型为<code>undefined</code>,<code>null</code>是一种特殊的<code>object</code>，<code>NaN</code>是代表非数字值得特殊值，说明某些算数运算（如求负数的平方根）的结果不是数字，如方法parseInt()和parseFloat()在不能解析制定的字符串时就返回这个值。</p>

<h4>2.比较</h4>

<pre><code>var s1; //s1 值为undefined
var s2 = null;
var s3 = NaN;

alert(s1 == s2); // 显示"true"
alert(s1 != s2); // 显示"false"

alert(s1 == s3); // 显示"false"
alert(s1 != s3); // 显示"true"

alert(s2 == s3); // 显示"false"
alert(s2 != s3); // 显示"true"

alert(s3 == s3); // 显示"false"
alert(s3 != s3); // 显示"true"  
</code></pre>

<p>根据以上代码可以得出：（1）<code>undefiend</code>与<code>null</code>是相等的；(2)<code>NaN</code>与任何值都不相等，与自己也不相等。</p>

<h4>3. isNaN()函数</h4>

<p><code>isNaN()</code>函数用于检查其参数是否是非数字值，通常用于检测<code>pareFloat()</code>和<code>parseInt()</code>的结果，以判断它们表示的是否和合法的数字，当然也可以用<code>isNaN()</code>函数来检测算数错误，比如用0做出书情况：</p>

<pre><code>var day = new Date();
alert(isNaN(3.1415926));        //false
alert(isNaN(day));            //false
alert(isNaN('BeginMan'));    //true
alert(isNaN("2005/12/12"));    //true
alert(isNaN(NaN));
</code></pre>

<h4>4. undefined 类型判断</h4>

<pre><code>var test;
if(test == undefined) {
    console.log("----------测试一------------");
}
//用typeof操作符返回的是字符串
if(typeof(test) == "undefined") {
   console.log("----------测试二------------")
} 
</code></pre>

<h3>二、 call()和apply()</h3>

<p>一直搞不明白这两个玩意儿的联系和区别，网上查了点资料，整理如下。</p>

<h4>1.联系</h4>

<p><code>apply()</code>和<code>call()</code>都能劫持另外一个对象的方法，集成另外一个对象的属性：</p>

<pre><code>function1.apply(obj,args)；
</code></pre>

<p><strong>obj</strong>:这个对象将代替<code>function1</code>类中的<code>this</code>对象，即<code>function1</code>函数里的<code>this</code>不再指向<code>function1</code>自身，而是指向<code>obj</code>对象。 <br/>
<strong>args</strong>:数组类型的参数，作为参数传给<code>function</code>。</p>

<p><code>call()</code>和<code>apply()</code>类似，只是参数类表不一样，如下：</p>

<pre><code>function2.call(obj,[param1[,param2[...[,paramN]]]]);
</code></pre>

<p><strong>obj</strong>:该对象将代替<code>function2</code>类中的<code>this</code>对象，与<code>apply()</code>类似。  <br/>
<strong>params</strong>:参数列表（用逗号二凯的0个或者多个参数），注意，这不是数组。</p>

<p><span style="color:red;font-weight: bold;">调用了这两个方法的结果</span>：依然执行了<code>function</code>函数的功能，只是该<code>function</code>以另一个目标对象和一个参数列表。</p>

<h4>2. 区别</h4>

<p>用法不相同，主要是参数不完全相同。</p>

<p>测试代码：</p>

<pre><code>    function Person(name,age) {    
        this.name=name;    
        this.age=age;    
        this.money = 500;  
    }   

    function myFun() {       
        alert(this.money);  
    }  

    var money = 100;  
    myFun(money);   
    //return 100;  
    //window.myFun(money); 
    //这个时候this指向的是window对象，其实myFun函数和定义的var money = 100;都作为window对象子对象（即全局对象）  

    myFun.apply(window,[]);  //save to window.myFun.apply(window,[]);    
    //return 100;  //同上  

    myFun.apply(new Person('zhangsan',23),[]);    
    //return 500, 空数组作为参数，仅符合语法要求  
    //这个时候myFun方法里面的this指向的是new Person('zhangsan',23)对象，二不是myFun类(函数)，故弹出500  

    myFun.call(new Person('zhangsan',23),money,300,'mycardId');    
    //return 500, 后面money,300和mycardId是参数列表作为参数，一一列出  
    //这个时候myFun方法里面的this指向的是new Person('zhangsan',23)对象，二不是myFun类(函数)，故弹出500  
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[主流浏览器简介]]></title>
    <link href="http://senola.github.io/blog/2014/07/19/browser-info/"/>
    <updated>2014-07-19T13:45:23+08:00</updated>
    <id>http://senola.github.io/blog/2014/07/19/browser-info</id>
    <content type="html"><![CDATA[<p>对一个web开发者来说，浏览器信息和统计数据是非常重要的。熟知他们才能更好的运用他们。</p>

<p>浏览器是指可以显示网页服务器或者文件系统的<code>HTML</code>内容，并让用户与这些文件交互的一种人间。网页浏览器主要通过<code>HTTP</code>协议也网页服务器交互并湖区网页，这些网页由<code>URL</code>制定，文件格式通常为<code>HTML</code>，并由<code>MIME</code>在<code>HTTP</code>协议中指明。常见的网页浏览器有：微软的<code>Internet Explorer</code>、Mozilla的<code>FireFox</code>、<code>Apple</code>的<code>Safari</code>,<code>Opera</code>、<code>Google Chrome</code>等。</p>

<!--more-->


<h4>浏览器的发展</h4>

<p>蒂姆.伯纳斯-李（Tim Berners-Lee）是第一个使用超文本来分享资讯的人，他于1990年发明了收割网页浏览器&mdash;<code>WorldWideWeb</code>，话说这么年我出生了！没想到浏览器竟然跟俺一样大，吼吼，小小激动了下 (^o^)/~。在1991年3月，他把这发明介绍了给他在CERN工作的朋友，从那时起浏览器的发展就和网络的发展联系在了一起。</p>

<p>下面来了解一下各主流浏览器。</p>

<h4>Internet Explorer</h4>

<p>首先，<code>Internet Explorer</code>是目前使用最为广泛的网页浏览器，为什么呢？因为它是捆绑在window系统上的，有着得天独厚的优势。但随着时代的发展，<code>IE</code>浏览器严重落后于新技术以及不遵循<code>W3C</code>规范，其在浏览器是市场所占的份额逐渐下降。深得开发人员鄙视~</p>

<p>2009年3月19日，微软发布了<code>Windows Internet Explorer 8</code>简体中文正式版。从以后的<code>IE9</code>、<code>IE10</code>、<code>IE11</code>的用户数来看，<code>IE8</code>的使用群体稳居榜首。这或许当下<code>WindowXP</code>用户数居多的原因吧！有一点不能理解就是，<code>IE</code>各版本没有给更新的提示。访问网页速度慢，兼容性差是<code>IE</code>浏览器的硬伤，幸运的是，微软于2014年4月8日起彻底取消对WindowsXP的所有技术支持。这或许意味着<code>windowXP</code>用户数会有一定程度的降低，而用户选择<code>win7</code>或<code>win8</code>的话也就间接地抛弃了低版本<code>IE</code>浏览器。可是，不可否认这是一个漫长的过程。。。</p>

<h4>Firefox</h4>

<p>Mozilla Firefox是一个开源的浏览器,它体积小速度快，主要特性有:标签式浏览;屏蔽弹出式窗口;自定制工具栏;扩展管理;更好的搜索特性;便捷的侧栏.此版本做了很大的更新,代码更优秀,功能更强大,包括安装程序,界面和下载管理器都作了很大的改进.力求功能上的更大完美。</p>

<h4>Opera</h4>

<p>Opera 是作为挪威电信公司Telenor的一个研究项目于1994年启动的，并于1995 发展为一个独立的开发公司，Opera Software ASA。它一款极为出色的浏览器，具有速度快、节省系统资源、订制能力强、安全性高以及体积小等特点。多文件接口(MDI)、方便的缩放功能、整合搜索引擎、键盘截径与鼠标浏览功能、对HTML标准的支持、整合电子邮件与新闻群组以及让使用者自订接口按钮、skin、工具列等的排列方式，都是Opera多年来备受喜爱的特殊功能。Opera除了在Windows外，也支持Linux、Mac等操作系统，同时内建的Opera在Symbian操作系统的浏览器.成为功能强大的手机浏览器之一,也是最受欢迎的浏览器之一.</p>

<h4>Chrome</h4>

<p>Google Chrome是由Google开发的一款设计简单、高效的Web浏览工具。Google凭借自己在搜索引擎领越的独特优势打造而成，其特点是支持多标签浏览，在提高安全性的同时，一个标签页面的崩溃也不会导致其他标签页面被关闭。此外，Google Chrome基于更强大的JavaScript V8引擎，这是当前Web浏览器所翘首期盼的。Google官方声称将开放Chrome的全部源代码。这将是许多开源软件爱好者的福音。个人最喜欢的一款浏览器，高端大气有档次。</p>

<h4>Safari</h4>

<p>Safari浏览器基于苹果Mac OS X平台的，多标签的网络浏览器。苹果发布的Windows版本的Safari，它支持Windows XP和Windows Vista操作系统，目前Safari 3.1正式版已经发布。支持多国语言版，适应简体中文界面，能够浏览绝大部分中文网页。Safari的特性包括：SnapBack、内嵌搜索功能、书签重命名、简化的下载流程等，这款浏览器是苹果针对公司战略的一个调整，目的是推出自主核心的浏览器慢慢吸取属于微软的市场份额。</p>

<h4>浏览器双核及CPU双核</h4>

<p>浏览器的双核就好比走路时脚上穿一只鞋，肩膀上还背着一双。见到制定的路（网页）就自动换鞋。所谓的双核是一般网页用chrome内核打开，网银等制定的网页用IE内核打开。由于哪些网页必须用IE内核，哪些用chrome打开很难全部预判出来，所以经常发生不能正常显示网页的问题，而且由于要运行两个内核，导致内存及CPU占用率都翻了一番。</p>

<h4>基于引擎区分</h4>

<h6>1.基于Gecko排版引擎</h6>

<p>Mozilla Firefox 、HotBrowser等</p>

<h6>2.基于WebKit排版引擎</h6>

<p>Google Chrome、Safari、Opera</p>

<h6>3.基于Trident排版引擎</h6>

<p>Internet Explorer</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[javascript获取随机数方法]]></title>
    <link href="http://senola.github.io/blog/2014/07/19/javascript-getrandnum/"/>
    <updated>2014-07-19T10:47:19+08:00</updated>
    <id>http://senola.github.io/blog/2014/07/19/javascript-getrandnum</id>
    <content type="html"><![CDATA[<p>研究了一下<code>javascript</code>关于随机数的生成，整理如下。</p>

<p>要输出随机数则须用到<code>javascript</code>的一个方法&mdash;<code>random()</code>，<code>random()</code>方法属于<code>Math</code>对象。在<code>javascript</code>中，<code>Math</code>对象用于执行数学任务，如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  var pi_value = Math.PI; //圆周率     
</span><span class='line'>  var sqrt_value = Math.sqrt(5);// 返回5的平方根</span></code></pre></td></tr></table></div></figure>


<p>可以看出<code>Math</code>对象在数学计算上是不可缺少的工具。与<code>Date</code>，<code>String</code>不同，她不是对象的类，因此没有构造函数<code>Math()</code>。像<code>Math.sin()</code>这样的函数只是函数，并不是某个对象的方法。你不需要创建它，通过把<code>Math</code>作为对象使用即可以条用她的所有属性及方法。</p>

<!--more-->


<h4>Math 的属性</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>E:返回算术常量 e，即自然对数的底数（约等于2.718）
</span><span class='line'>LN2:返回 2 的自然对数（约等于0.693）
</span><span class='line'>LN10:返回 10 的自然对数（约等于2.302）
</span><span class='line'>LOG2E:返回以 2 为底的 e 的对数（约等于 1.414）
</span><span class='line'>LOG10E:返回以 10 为底的 e 的对数（约等于0.434）
</span><span class='line'>PI:返回圆周率（约等于3.14159）
</span><span class='line'>SQRT1_2:返回返回 2 的平方根的倒数（约等于 0.707）
</span><span class='line'>SQRT2:返回 2 的平方根（约等于 1.414）</span></code></pre></td></tr></table></div></figure>


<h4>Math 的方法</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>abs(x):返回数的绝对值
</span><span class='line'>acos(x):返回数的反余弦值
</span><span class='line'>asin(x):返回数的反正弦值
</span><span class='line'>atan(x):以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值
</span><span class='line'>atan2(y,x):返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）
</span><span class='line'>ceil(x):对数进行上舍入
</span><span class='line'>cos(x):返回数的余弦
</span><span class='line'>exp(x):返回 e 的指数
</span><span class='line'>floor(x):对数进行下舍入
</span><span class='line'>log(x):返回数的自然对数（底为e）
</span><span class='line'>max(x,y):返回 x 和 y 中的最高值
</span><span class='line'>min(x,y):返回 x 和 y 中的最低值
</span><span class='line'>pow(x,y):返回 x 的 y 次幂
</span><span class='line'>random():返回 0 ~ 1 之间的随机数
</span><span class='line'>round(x):把数四舍五入为最接近的整数
</span><span class='line'>sin(x):返回数的正弦
</span><span class='line'>sqrt(x):返回数的平方根
</span><span class='line'>tan(x):返回角的正切
</span><span class='line'>toSource():返回该对象的源代码
</span><span class='line'>valueOf():返回 Math 对象的原始值</span></code></pre></td></tr></table></div></figure>


<p>了解<code>Math</code>对象的相关属性及方法会有意想不到的好处。今天主要研究一下<code>random()</code>方法，在<code>chrome</code>控制台输入：</p>

<pre><code>Math.random(); //回车
---&gt; 0.7504939001519233
Math.random(); //回车
---&gt; 0.7824516440741718
typeof(Math.random()); //回车
---&gt; "number" 
</code></pre>

<p>可以看出<code>random()</code>方法返回的是0 ~ 1之间的伪随机数。注意，可能为0，但总是小于1即生成数的范围是[0,1)。利用<code>javascript</code>取整方法<code>parseInt（）</code>即可获取[0,1)之间的整数，如：</p>

<pre><code>parseInt(Math.random() * 10); // 回车
---&gt; 3
parseInt(Math.random() * 10); // 回车
---&gt; 4
parseInt(Math.random() * 10); // 回车
---&gt; 6
Math.floor(Math.random()*10 + 1); //获取[1,10] 之间的随机数
---&gt; 10
</code></pre>

<p>由此，并可以获得了[0,1)之间的随机整数值，那么如果想要获取多位随机数（如4444,321,4443）又该如何操作呢？这里可以先随机出n位数，在将这n位数用连接符<code>+</code>连接起来即可，如下：</p>

<pre><code>function RndNum(n) {
    var rnd = "";
    for(var i = 0; i &lt; n; i++) {
       rnd += Math.floor(Math.random() * 10);
    }
    return rnd;
}
console.log("四位随机数： " + RndNum(4));　　//输出4位数的随机数的随机整数
console.log("八位随机数： " + RndNum(8));　　//输出8位数的随机数的随机整数
</code></pre>

<p>根据以上信息，我们要指定某个范围（如（2,3）内）的随机数就可以利用公式：<code>(Math.random()*(n-m)+m)</code>既可以返回m-n之间的随机数了，通用代码如下：</p>

<pre><code>&lt;!-- 获取随机正整数，对应的复数只需要加"-"号即可。0, 1 暂未判断 --&gt;
function getRandomNum( down, up) {
   switch (arguments.length) { //传入的参数个数
      case 1: 
          return parseInt(Math.random() * down + 1); // 获取[0,down)间的随机数
      case 2:
          return parseInt(Math.random() * (up - down + 1) + down); //获取[down,up] 之间的随机数
      default: 
          return 0; 
   }
}
// 测试代码
console.log("[0,1]间的随机整数：" + getRandomNum(100));
console.log("[2,5]间的随机整数：" + getRandomNum(2,5));
console.log("[1,10]间的随机整数：" + getRandomNum(1,10));
</code></pre>

<p>以上便是使用<code>random()</code>方法创建正整数随机数的方法。当然我们还可以基于时间来创建， 如：</p>

<pre><code>var now_time = new Date();
var second_num = now_time.getSeconds(); //产生一个基于目前时间的0到59的整数
var timestamp_num = now_time.getTime(); //产生一个基于目前时间等我时间戳
console.log("秒随机数：" + num);
console.log("时间戳随机数：" + timestamp_num);
</code></pre>

<h4>总结</h4>

<p>随机数的使用场景随处可见，如可以利用她创建随机的文本、表单、标题广告、背景图片。背景音乐及背景颜色等等。。。掌握了原理，如何运用也就是一码事儿！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用javascript判断各浏览器类型及版本]]></title>
    <link href="http://senola.github.io/blog/2014/07/17/get-browser-type/"/>
    <updated>2014-07-17T12:40:16+08:00</updated>
    <id>http://senola.github.io/blog/2014/07/17/get-browser-type</id>
    <content type="html"><![CDATA[<p>今天要在<code>IE</code>下测试大文件上传插件，发现项目组&#8221;前辈&#8221;们写的判断<code>IE</code>浏览器的的代码不管用了。</p>

<pre><code>navigator.userAgent.toLowerCase().indexOf("msie") != -1；
</code></pre>

<p>调试代码才发现原来<code>IE11</code>下<code>userAgent</code>值的格式与<code>IE10</code>不一样。打印出ie9,ie10,ie11三个版本的浏览器userAgent值，如下所示：</p>

<pre><code>IE9：userAgent:Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)    
IE10:userAgent:Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)  
IE11:userAgent:Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; rv:11.0) like Gecko;
</code></pre>

<!--more-->


<p>可以看出，前两者（IE9,IE10）都含有<code>MSIE</code>这样一个值而后面紧接着的是<code>IE</code>浏览器的版本号。而奇葩的<code>IE11</code>的<code>userAgent</code>又重新做了调整，不再用<code>MSIE</code>来标识浏览器版本号，而是用的 <code>rv</code>。神奇吧，让我们再一次向这个让无数码农挥洒汗水的浏览器致敬！！╮(╯▽╰)╭</p>

<p>所以单纯的判断浏览器类型是否是<code>IE</code>的话，就要多增加一个<code>IE11</code>的判断了。（<code>IE12</code>貌似出来了，没测试过。。）但是如果<code>IE13</code>问世了，那么这个<code>userAgent</code>的值是不是又会改变呢？到时候是不是又得回来多添加一行专门为<code>IE13</code>而处理的语句？？如果是单纯的判断是否是<code>IE</code>浏览器的话，可以考虑不用<code>userAgent</code>,我们知道只有<code>IE</code>浏览器支持创建<code>ActiveX</code>控件，因此她有一个其他浏览器没有的东西&mdash;ActiveXObject函数，所以只需要判断<code>window</code>对象中是否存在<code>ActiveObject</code>函数就可以很明确的判断出当前的浏览器是否是神器<code>IE</code>：</p>

<pre><code>function isIE () { //判断是否是IE（ie11下也适合）  
    if( window.ActiveXObject || "ActiveXObject" in window) {
        console.log("I am IE");
    } else {
        console.log("I not IE");
    }
}
</code></pre>

<p>看到上边代码就能发现为什么多了一个<code>"ActiveXObject" in window</code>判断？没错那个还是因为<code>IE11</code>。查了点资料貌似是因为<code>IE11</code>中<code>window.ActiveObject</code>属性在<code>DOM</code>中是隐藏的，也就是说你不能在<code>IE11</code>中用<code>window.ActiveObject</code>来判断。有兴趣可以去参考下 <a href="http://msdn.microsoft.com/en-us/library/ie/dn423948%28v=vs.85%29.aspx" target="_blank">Cross-browser plugin detection</a>,反正我没啥兴趣，吼吼~</p>

<p>地球是一个很神奇的世界，你知道这个世界上有多少种浏览器吗？除了我们熟知的IE, Firefox, Opera, Safari四大浏览器之外，世界上还有近百种浏览器~ 当然我们还是只关心这些主流的浏览器，其他的也没精力，没时间去折腾！</p>

<p>浏览器的世界太奇妙，我们不懂！</p>

<p>额，既然<code>IE</code>都说了，其他的也学习下吧~~IE就不提了。</p>

<h3>Firefox</h3>

<p><code>firefox</code>中的<code>DOM</code>元素都有一个<code>getBoxObjectFor</code>函数，用来获取该<code>DOM</code>元素的位置和大小（IE对应的是getBoundingClientRect）。这是<code>firefox</code>独有。<code>firefox</code>下的<code>userAgent</code>大致如下：</p>

<pre><code> Mozilla/5.0 (Windows; U; Windows NT 5.2) Gecko/2008070208 Firefox/3.0.1
 Mozilla/5.0 (Windows; U; Windows NT 5.1) Gecko/20070309 Firefox/2.0.0.3
 Mozilla/5.0 (Windows; U; Windows NT 5.1) Gecko/20070803 Firefox/1.5.0.12
</code></pre>

<p>可根据<code>Firefox</code>后面的数字来获取版本号。</p>

<h3>Opera</h3>

<p> <code>Opera</code>提供了专门的浏览器标志是<code>window.opera</code>属性。Opera浏览器的userAgent如下：</p>

<pre><code>Opera/9.27 (Windows NT 5.2; U; zh-cn)
Opera/8.0 (Macintosh; PPC Mac OS X; U; en)
Mozilla/5.0 (Macintosh; PPC Mac OS X; U; en) Opera 8.0 
</code></pre>

<p>获取靠近<code>Opera</code>的数字即为浏览器版本号。</p>

<h3>Safari</h3>

<p><code>Safari</code>浏览器中有一个其他浏览器没有的<code>openDatabase</code>函数，可做为判断Safari的标志。Safari典型的userAgent如下：</p>

<pre><code>Mozilla/5.0 (Windows; U; Windows NT 5.2) AppleWebKit/525.13 (KHTML, like Gecko) Version/3.1 Safari/525.13
Mozilla/5.0 (iPhone; U; CPU like Mac OS X) AppleWebKit/420.1 (KHTML, like Gecko) Version/3.0 Mobile/4A93 Safari/419.3 
</code></pre>

<p>获取<code>version</code>之后的数字，即是获取浏览器版本号。</p>

<h3>Chrome</h3>

<p>本人最热衷的浏览器！！ <code>Chrome</code>有一个<code>MessageEvent</code>函数，但Firefox也有。不过，好在<code>Chrome</code>并没有<code>Firefox</code>的<code>getBoxObjectFor</code>函数，根据这个条件还是可以准确判断出<code>Chrome</code>浏览器的。目前，<code>Chrome</code>的<code>userAgent</code>是：</p>

<pre><code>Mozilla/5.0 (Windows; U; Windows NT 5.2) AppleWebKit/525.13 (KHTML, like Gecko) Chrome/0.2.149.27 Safari/525.13
</code></pre>

<p>可以看到，<code>chrome</code>的<code>userAgent</code>中还包含了<code>safar</code>的特征，这或许就是为什么<code>Chrome</code>可以运行所有<code>Apple</code>浏览器应用的基础吧。</p>

<p>so,根据以上特性可以经浏览器的版本判断整合在一起，如下：</p>

<pre><code>&lt;script type="text/javascript"&gt;
    function  browserCheck () { // 各个浏览器判断
        var Sys = {};
        var ua = navigator.userAgent.toLowerCase(); //获取 userAgent 值
        var s;
        (s = ua.match(/rv:([\d.]+)\) like gecko/)) ? Sys.ie = s[1] : //IE 11
        (s = ua.match(/msie ([\d.]+)/)) ? Sys.ie = s[1] :
        (s = ua.match(/firefox\/([\d.]+)/)) ? Sys.firefox = s[1] :
        (s = ua.match(/chrome\/([\d.]+)/)) ? Sys.chrome = s[1] :
        (s = ua.match(/opera.([\d.]+)/)) ? Sys.opera = s[1] :
        (s = ua.match(/version\/([\d.]+).*safari/)) ? Sys.safari = s[1] : 0;

        if (Sys.ie) console.log('IE: ' + Sys.ie);
        if (Sys.firefox) console.log('Firefox: ' + Sys.firefox);
        if (Sys.chrome) console.log('Chrome: ' + Sys.chrome);
        if (Sys.opera) console.log('Opera: ' + Sys.opera);
        if (Sys.safari) console.log('Safari: ' + Sys.safari);
    };
&lt;/script&gt;
</code></pre>

<p>往这儿瞧瞧&mdash;>: <a href="http://senola.github.io/collections/javascript/getBrowserType/getBrowserType.html" target="_blank" style="color:green;font-weight:bold;">测试地址</a></p>

<h3>总结：</h3>

<pre><code>1. 浏览器种类繁多，各浏览器有很多不同之处，有必要熟悉。
2. IE浏览器使用人居多，有必要知晓其相关特别之处。
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解决 Permission denied(publicKey) 问题]]></title>
    <link href="http://senola.github.io/blog/2014/07/13/git-error/"/>
    <updated>2014-07-13T09:03:47+08:00</updated>
    <id>http://senola.github.io/blog/2014/07/13/git-error</id>
    <content type="html"><![CDATA[<p>好几个月没碰过<code>github Pages</code>了，一整就来事儿，花了一下午才搞定。现把问题和解决方法记录下来，以做参考。在用<code>git</code>向<code>github</code>服务器<code>push</code>代码的时候，出现了一下情况：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> Pushing generated _deploy website Permission denied (publickey). fatal: Could not read from remote...</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>折腾了一下，终于定位到问题所在了，原因是之前在本地生成<code>github</code>的<code>ssh key</code>失效了，导致<code>github</code>服务器验证提交请求失败，进而拒绝提交代码操作。好了，定位到问题所在就好办了，接下来就是初始化<code>SSH key</code>就行了。</p>

<p>右键&mdash;&ndash;>git bath，在控制台中输入：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  ssh-keygen</span></code></pre></td></tr></table></div></figure>




<!--more-->


<p>一路Enter,如果已存在<code>id_rsa</code>文件的话，会提示你是否将其覆盖，键入<code>y</code>即可，如图:</p>

<p><img src="https://raw.githubusercontent.com/senola/pictures/master/git/git_bath01.jpg" alt="show info" /></p>

<p>找到<code>id_rsa</code>文件，这个文件目录随个人系统而定，我的是在<code>/c/Users/fosenola/.ssh/</code>下.找到一个叫<code>id_rsa.pub</code>的文件（特别注意，是<code>id_rsa.pub</code>),而后用文本编辑器（因为待会复制的时候不能复制到空格，否则会出现各种你不想见到的问题），如<code>notepad++、UltraEdit</code>等。接下来登入<a href="https://github.com/" target="_blank">github</a>网站，点击右上角<code>Acount Settings</code>&mdash;>SSH Keys &mdash;> Add SSH Key,如图：</p>

<p><img src="https://raw.githubusercontent.com/senola/pictures/master/git/github_sshkey_set.jpg" alt="show info" /></p>

<p><span style="color:red;font-weight: bold;">注意,上图中钥匙图标旁边的绿色小点表示该<code>SSH Key</code>状态为正在使用，灰色表示为使用或者已失效。可以用一下命令测试刚才加入的<code>SSH Key</code>是否成功：<span></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ssh -T git@github.com</span></code></pre></td></tr></table></div></figure>


<p>如果提示仍为“github,Permission denied(publicKey)”则表示<code>ssh key</code>设置失败，如果是“hello &hellip;，you&rsquo;ve successfully&hellip;”那么，恭喜，成功了！并且可以再刚才设置的<code>SSH Key</code>界面上看到灰色小点便成了绿色。</p>

<p><img src="https://raw.githubusercontent.com/senola/pictures/master/git/git_bath02.jpg" alt="show info" /></p>

<p>至此，就可以再试试<code>git push</code>命令了。当然以上只是自己在网上瞎找的方法，后来才知道自己太二了，这种东西官网才是王道。官网上不仅有<code>windows</code>，更有<code>MAC</code>、<code>Linux</code>下的解决方法。<a href="https://help.github.com/articles/generating-ssh-keys#platform-windows" target="_blank" style="color:green;font-weight:bold">猛戳这里</a></p>

<p>思考了一番，总结了几点：</p>

<pre><code>1. 遇到问题后不慌，先定位问题再找解决之法。   
2. 不轻易谷歌或者百度。   
3. 官方文档才是第一手资料。  
4. 所谓的大神就是啃多了第一手资料。  
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[上传插件之----Web Uploader]]></title>
    <link href="http://senola.github.io/blog/2014/04/28/webupload/"/>
    <updated>2014-04-28T23:22:45+08:00</updated>
    <id>http://senola.github.io/blog/2014/04/28/webupload</id>
    <content type="html"><![CDATA[<p>最近云盘要大改版，前端采用了谷歌的<code>AngularJS</code>框架。大改嘛，之前云盘用插件要换的也都要换。飞哥说插件可以用但是却不能乱用，尤其是将其用于商业领域的，必须慎重加慎重，首先选选择的插件得符合相关的开原协议（如上篇），因滥用别的插件而上法庭的例子举不胜数。作为小菜的我一直都以够用，管用，好用的心态去用这些插件的，什么开原协议啊，什么版权啊之类的，不懂~大神告诉我，这个很重要，因为一旦被查出，后果很严重。。。飞哥推荐使用以<code>MIT</code>开源协议发布的<code>Web Uploader</code>作为上传插件。研究了它几天，苦恼，痛苦，桑心&hellip;</p>

<!-- more -->


<p><a href="http://gmuteam.github.io/----------er" target="_blank"><strong>Web Uploader</strong></a> 是由<code>Baidu WebFE(FEX)</code>团队开发的一个简单的以<code>HTML5</code>为主，<code>FLASH</code>为辅的现代文件上传组件。在现代的浏览器里面能充分发挥<code>HTML5</code>的优势，同时又不摒弃主流IE浏览器，沿用原来的<code>FLASH</code>运行时，兼容IE6+。两套运行时，同样的调用方式，可供用户任意选用。采用大文件分片并发上传，极大的提高了文件上传效率。特点如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>分片、并发  
</span><span class='line'>预览、压缩  
</span><span class='line'>多途径添加文件   
</span><span class='line'>HTML5 & FLASH  
</span><span class='line'>MD5秒传   
</span><span class='line'>易扩展，可拆分     </span></code></pre></td></tr></table></div></figure>


<p>看着介绍貌似很吊，于是demo走起&hellip;. <br/>
官网的第一个<code>demo</code>就把我给吓尿了，这文档也太简单了吧！！！据飞哥说他们团队游50多人，我只想说你们把文档写这么简单你家人知道吗？？？照着做本地硬是跑不通！无奈只能在它官网<code>F12</code><del>(>_&lt;)</del></p>

<p>一、引入JS、css。<code>webuploader.js</code>可以在官网在下载，<code>cloudupload.js</code>是上传前各参数的初始化及上传结果处理,<code>bootstrap.min.css</code>是<code>bootstrap</code>框架的核心文件，可以在官网下载:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;link rel="stylesheet" href="libs/bootstrap/css/bootstrap.min.css"/&gt;
</span><span class='line'>&lt;script type="text/javascript" src="libs/webupload/webuploader.js"&gt;&lt;/script&gt;
</span><span class='line'>&lt;script type="text/javascript" src="libs/webupload/cloudupload.js"&gt;&lt;/script&gt;</span></code></pre></td></tr></table></div></figure>


<p>二、html模块，包含存放文件信息的容器、选择按钮和上传按钮三个部分。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;div id="uploader" class="wu-example"&gt;
</span><span class='line'>    &lt;!--用来存放文件信息--&gt;
</span><span class='line'>    &lt;div id="thelist" class="uploader-list"&gt;&lt;/div&gt;
</span><span class='line'>    &lt;div class="btns"&gt;
</span><span class='line'>        &lt;div id="picker"&gt;选择文件&lt;/div&gt;
</span><span class='line'>        &lt;button id="ctlBtn" class="btn btn-default"&gt;开始上传&lt;/button&gt;
</span><span class='line'>    &lt;/div&gt;
</span><span class='line'>&lt;/div&gt;</span></code></pre></td></tr></table></div></figure>


<p>三、初始化上传参数（webuploader.js）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var $ = jQuery,
</span><span class='line'>$list = $('#thelist'),
</span><span class='line'>$btn = $('#ctlBtn'),
</span><span class='line'>state = 'pending'; //上传状态
</span><span class='line'>window.fileList = []; //获取要上传的文件列表数组
</span><span class='line'>var uploader = WebUploader.create({
</span><span class='line'>    // swf文件路径
</span><span class='line'>    swf: '/web2/libs/webupload/Uploader.swf',
</span><span class='line'>    // 文件接收服务端。
</span><span class='line'>    server: 'http://webuploader.duapp.com/server/fileupload.php',
</span><span class='line'>    // 选择文件的按钮。可选。
</span><span class='line'>    // 内部根据当前运行是创建，可能是input元素，也可能是flash.
</span><span class='line'>    pick: id,
</span><span class='line'>
</span><span class='line'>    // 不压缩image, 默认如果是jpeg，文件上传前会压缩一把再上传！
</span><span class='line'>    resize: false
</span><span class='line'>});
</span><span class='line'>
</span><span class='line'>//当有文件被添加进队列的时候
</span><span class='line'>uploader.on( 'fileQueued', function( file ) {
</span><span class='line'>  //发送ajax请求道后台 返回从后台拼装的SAL上传url
</span><span class='line'>  $.ajax({
</span><span class='line'>      type : 'POST',
</span><span class='line'>      url : '/cloud-web/upload/getUploadUrl.htm',
</span><span class='line'>      data: {
</span><span class='line'>          "fileName": file.name,
</span><span class='line'>          "folderId": window.currentFolderId,
</span><span class='line'>          "size": file.size
</span><span class='line'>      },
</span><span class='line'>      dataType: 'json',
</span><span class='line'>      success: function(data){
</span><span class='line'>          file.server = data.uploadUrl;
</span><span class='line'>          console.log("sal url-------&gt;" + data.uploadUrl);
</span><span class='line'>      },
</span><span class='line'>      error : function(data){
</span><span class='line'>          //错误提示
</span><span class='line'>          console.log("获取上传地址错误...");
</span><span class='line'>      }
</span><span class='line'>    });
</span><span class='line'>  fileList.push(file); //将要上传的文件加入fileList数组
</span><span class='line'>  $list.append( '&lt;div id="' + file.id + '" class="item"&gt;' +
</span><span class='line'>        '&lt;h4 class="info"&gt;' + file.name + '&lt;/h4&gt;' +
</span><span class='line'>        '&lt;p class="state"&gt;等待上传...&lt;/p&gt;' +
</span><span class='line'>    '&lt;/div&gt;' );
</span><span class='line'>});
</span><span class='line'>
</span><span class='line'>//文件上传过程中创建进度条实时显示。
</span><span class='line'>uploader.on( 'uploadProgress', function( file, percentage ) {
</span><span class='line'>    var $li = $( '#'+file.id ),
</span><span class='line'>        $percent = $li.find('.progress .progress-bar');
</span><span class='line'>    // 避免重复创建
</span><span class='line'>    if ( !$percent.length ) {
</span><span class='line'>        $percent = $('&lt;div class="progress progress-striped active"&gt;' +
</span><span class='line'>          '&lt;div class="progress-bar" role="progressbar" style="width: 0%"&gt;' +
</span><span class='line'>          '&lt;/div&gt;' +
</span><span class='line'>        '&lt;/div&gt;').appendTo( $li ).find('.progress-bar');
</span><span class='line'>    }
</span><span class='line'>    $li.find('p.state').text('上传中');
</span><span class='line'>    $percent.css( 'width', percentage * 100 + '%' );
</span><span class='line'>    $percent.attr( 'uploadProgress', percentage);
</span><span class='line'>});
</span><span class='line'>
</span><span class='line'>//文件上传完成
</span><span class='line'>uploader.on( 'uploadComplete', function( file ) {
</span><span class='line'>  //上传完成隐藏进度条
</span><span class='line'>  $( '#'+file.id ).find('.progress').fadeOut();
</span><span class='line'>});
</span><span class='line'>//文件上传成功
</span><span class='line'>uploader.on( 'uploadSuccess', function( file ) {
</span><span class='line'>  $( '#'+file.id ).find('p.state').text('已上传');
</span><span class='line'>});
</span><span class='line'>//文件上传失败
</span><span class='line'>uploader.on( 'uploadError', function( file ) {
</span><span class='line'>  $( '#'+file.id ).find('p.state').text('上传出错');
</span><span class='line'>});
</span><span class='line'>//文件上传各个部分监听
</span><span class='line'>uploader.on( 'all', function( type ) {
</span><span class='line'>    if ( type === 'startUpload' ) {
</span><span class='line'>        state = 'uploading';
</span><span class='line'>    } else if ( type === 'stopUpload' ) {
</span><span class='line'>        state = 'paused';
</span><span class='line'>    } else if ( type === 'uploadFinished' ) {
</span><span class='line'>        state = 'done';
</span><span class='line'>    }
</span><span class='line'>});
</span><span class='line'>//按钮添加监听事件
</span><span class='line'>$btn.on( 'click', function() {
</span><span class='line'>    if ( state === 'uploading' ) {
</span><span class='line'>        uploader.stop();
</span><span class='line'>    } else {
</span><span class='line'>        uploader.upload();
</span><span class='line'>    }
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>蛋疼的紧，官网demo代码少的可怜~  效果见官网。</p>

<p>紧接着遇到第二个难题，云盘现在文件上传采用的是<code>SAL</code>（存储访问层）模式，即每一个文件都要从服务端获取一个上传点，然后上传插件在向上传点进行上传操作。这里就存在一个问题，从上面我们发现要进行上传操作我们需要创建<code>Web Uploader</code>实例:WebUploader.create{&hellip;},我们发现在创建实例的时候需要传入一个文件接收服务端<code>server</code>,这就遇到了难题，我们上传模式是一个文件对应一个上传<code>URL</code>，而次插件又没有提供类似的方法可以动态修改每个<code>server</code>对应的值。经过不懈的努力外加看源码再加各种测试，终于搞定了~··</p>

<p>首先，定义一个全局数组<code>window.fileList = [];</code>用于获取要上传的文件列表数组，然后在文件加入队列的时候对数组进行push操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//当有文件被添加进队列的时候
</span><span class='line'>uploader.on( 'fileQueued', function( file ) {
</span><span class='line'>  //发送ajax请求道后台 返回从后台拼装的SAL上传url
</span><span class='line'>  $.ajax({
</span><span class='line'>      type : 'POST',
</span><span class='line'>      url : '/cloud-web/upload/getUploadUrl.htm',
</span><span class='line'>      data: {
</span><span class='line'>          "fileName": file.name,
</span><span class='line'>          "folderId": window.currentFolderId,
</span><span class='line'>          "size": file.size
</span><span class='line'>      },
</span><span class='line'>      dataType: 'json',
</span><span class='line'>      success: function(data){
</span><span class='line'>          file.server = data.uploadUrl;
</span><span class='line'>          console.log("sal url-------&gt;" + data.uploadUrl);
</span><span class='line'>      },
</span><span class='line'>      error : function(data){
</span><span class='line'>          //错误提示
</span><span class='line'>          console.log("获取上传地址错误...");
</span><span class='line'>      }
</span><span class='line'>    });
</span><span class='line'>  fileList.push(file); //将要上传的文件加入fileList数组
</span><span class='line'>  $list.append( '&lt;div id="' + file.id + '" class="item"&gt;' +
</span><span class='line'>        '&lt;h4 class="info"&gt;' + file.name + '&lt;/h4&gt;' +
</span><span class='line'>        '&lt;p class="state"&gt;等待上传...&lt;/p&gt;' +
</span><span class='line'>    '&lt;/div&gt;' );
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>file.server = data.uploadUrl;给每一个file对象增加一个该filefile对象对应的上传URL，fileList.push(file);将所有要上传的文件放入数组。接下来就是修改<code>webUpload.js</code>源码。定位<code>webUpload.js</code>第3876行，修改如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>send: function() {
</span><span class='line'>    var owner = this.owner,
</span><span class='line'>        opts = this.options,
</span><span class='line'>        xhr = this._initAjax(),
</span><span class='line'>        blob = owner._blob,
</span><span class='line'>        formData, binary;
</span><span class='line'>    
</span><span class='line'>    //将上传队列中的第一个文件的数组的上传地址放入server
</span><span class='line'>    //window.fileList.length 变量在cloudupload中定义
</span><span class='line'>    var server;
</span><span class='line'>  for(var i = 0 ;i &lt; window.fileList.length; i++){
</span><span class='line'>      if(window.fileList[i].id == opts.formData.id){
</span><span class='line'>          server = window.fileList[i].server;
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>    ....
</span><span class='line'>    ....</span></code></pre></td></tr></table></div></figure>


<p>此处遍历了<code>window.fileList</code>，根据每一个<code>file</code>对象的<code>id</code>进行匹配对应的上传<code>URL</code>。</p>

<p>到这里就基本OK了，看起来简单，可当初找起来真费事儿，头疼~~~，之后文件上传还遇到跨域问题，因为文件上传的服务器与服务端不是同一域名下，所以会出现跨域问题。经<code>ngnix</code>修改相关配置后将问题解觉&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[开源协议]]></title>
    <link href="http://senola.github.io/blog/2014/04/23/license/"/>
    <updated>2014-04-23T04:06:43+08:00</updated>
    <id>http://senola.github.io/blog/2014/04/23/license</id>
    <content type="html"><![CDATA[<p>越来越多的开发者与设计者希望将自己的产品开源，以便其他人可以在他们的代码基础上做更多事，开源社区也因此充满生机。在我们所能想到的应用领域，都有开源软件存在（如：<code>WordPress</code>，<code>Drupal</code>这些开源<code>CMS</code>）。不懂，所以学习下常见的几种开原协议~</p>

<h3>一、BSD</h3>

<p>BSD（Berkly Software Distribution）开源协议是一个给于使用者很大自由的协议。基本上使用者可以”为所欲为”,可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。 
但”为所欲为”的前提当你发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件： </p>

<!-- more -->


<pre><code>1. 如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。 
2. 如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。 
3. 不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。 
</code></pre>

<p><code>BSD</code>代码鼓励代码共享，但需要尊重代码作者的著作权。<code>BSD</code>由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。</p>

<h3>二、AL2.0</h3>

<p><code>Apache Licence</code>是著名的非盈利开源组织<code>Apache</code>采用的协议。该协议和<code>BSD</code>类似，同样鼓励代码共享和尊重原作者的著作权，同样允许代码修改，再发布（作为开源或商业软件）。需要满足的条件也和BSD类似：</p>

<pre><code>1.需要给代码的用户一份Apache Licence
2.如果你修改了代码，需要在被修改的文件中说明。
3.在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。
4.如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改。  
</code></pre>

<p>Apache Licence也是对商业应用友好的许可。使用者也可以在需要的时候修改代码来满足需要并作为开源或商业产品发布/销售。</p>

<h3>三、GPL</h3>

<p>我们很熟悉的Linux就是采用了GPL（GNU General Public License），<code>GPL</code>协议和<code>BSD</code>， <code>Apache Licence</code>等鼓励代码重用的许可很不一样。<code>GPL</code>的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代 码做为闭源的商业软件发布和销售。这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商 业软件公司开发的免费软件了。</p>

<p>GPL协议的主要内容是只要在一个软件中使用（”使用”指类库引用，修改后的代码或者衍生代码）GPL 协议的产品，则该软件产品必须也采用GPL协议，既必须也是开源和免费。这就是所谓的”传染性”。GPL协议的产品作为一个单独的产品使用没有任何问题， 还可以享受免费的优势。</p>

<p>由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和二次开发的基础。</p>

<p>其它细节如再发布的时候需要伴随GPL协议等和BSD/Apache等类似。</p>

<h3>四、LGPL（GNU Lesser General Public License）</h3>

<p>LGPL 是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL 允许商业软件通过类库引用（link）方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并 发布和销售。
但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因 此LGPL协议的开源 代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。
GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品。</p>

<h3>五、MIT</h3>

<p>MIT是和BSD一样宽范的许可协议，作者只想保留版权，而无任何其它的限制。也就是说，你必须在你的发行版里包含原许可协议的声明，无论你是以二进制发布的还是以源代码发布的。MIT协议又称麻省理工学院许可证，最初由麻省理工学院开发。被授权人权利：1、被授权人有权利使用、复制、修改、合并、出版发行、散布、再授权及贩售软件及软件的副本。2、被授权人可根据程式的需要修改授权条款为适当的内容。被授权人义务：在软件和软件的所有副本中都必须包含版权声明和许可声明。</p>

<p>在使用中具体如何选则呢？嘿，见下图：</p>

<p><img src="https://raw.githubusercontent.com/senola/pictures/master/freeLicenses/free_licenses.png" alt="free licenses" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS 学习之旅（一）]]></title>
    <link href="http://senola.github.io/blog/2014/04/07/20140406/"/>
    <updated>2014-04-07T01:41:40+08:00</updated>
    <id>http://senola.github.io/blog/2014/04/07/20140406</id>
    <content type="html"><![CDATA[<p><strong>前言</strong>：出来工作也快一年了，给我的感觉是学到的新东西并不是很多。不过，最近由于云盘前端需要重新改版，部门请来了一位前端大牛压阵。所以有幸认识了<code>AngularJS</code>，跟着大牛的脚步走进<code>AngularJS</code>的世界痛并快乐着&hellip;.</p>

<h2>一、简介</h2>

<p><a href="http://angularjs.org" target="_blank">AngularJS</a>是谷歌是<code>Google</code>推出的开源JavaScript MV*（MVW、MVVM、MVC）结构性的动态WEB程序应用框架。它允许你使用HTML模板语言,允许您扩展HTML语法，清晰、简洁地表达您的应用程序的组件。<code>AngularJS</code>的数据绑定和依赖注入减少了大部分你当前不得不写的代码，而且这一切都运行在浏览器内,使它能成为与任何服务器技术的理想合作伙伴。</p>

<!--more-->


<p>并不是所有的WEB APP都适合使用<code>AngularJS</code>,<code>AngularJS</code>最适合<strong><code>CRUD</code></strong>（CREATE READ UPDATE DELETE）类型的WEB APP。像<strong>Games</strong>、<strong>GUI</strong> <strong>editors</strong>这一不同于CRUD类型的app，它们更适合使用一些抽象层级较低的库，如<code>JQuery</code>。<span style="color:green"><strong>好吧，关于AngularJS的历史我觉得只要记住三点就行：谷歌的、开源的、适合CRUD类型的APP。</strong></span></p>

<h2>二、AngularJS 一些概念</h2>

<p>下面列举一些AngularJS的概念</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Template:使用了额外标记的HTML  
</span><span class='line'>Directives：使用自定义属性和元素扩展的HTML   
</span><span class='line'>Model:展示给用户和与用户进行交互的数据  
</span><span class='line'>Scope：model存数的上下文，以便controllers, directives and expressions能够访问       
</span><span class='line'>Expressions：能从Scope里访问的变量和函数    
</span><span class='line'>Compiler：解析模板和实例化指令和表达式  
</span><span class='line'>Filter：格式化表达式
</span><span class='line'>View:用户能看到的的数据（the DOM）
</span><span class='line'>Data Binding:model和view之间动态的数据
</span><span class='line'>Controller:展示视图（view）之前的业务逻辑处理   
</span><span class='line'>Dependency Injection：创建和连接对象或函数  
</span><span class='line'>Injector：依赖注入的容器  
</span><span class='line'>Module： 注入器的配置  
</span><span class='line'>Service:可重用业务逻辑独立的观点    </span></code></pre></td></tr></table></div></figure>


<h2>三、核心内容（core concepts）</h2>

<h3>1 Templates</h3>

<p>在<code>AngularJS</code>的应用程序中,您将用数据填充页面模板的工作从服务器到客户机。结果是一个系统更好的结构化动态页面更新。下面是您将使用的核心特性。</p>

<h4>1.1 Data binding</h4>

<p>在<code>AngularJS</code>中，<code>Data-binding</code>是指在model和view组件间动态同步的数据。这意味着在应用程序里使用<code>AngularJS</code>的<code>Data-binding</code>可以让你像single-source-of-truth一样操作model。当model内容改变时，view也跟着变化，反之亦然。</p>

<p>Data Binding in Angular Templates</p>

<p><img src="https://raw.githubusercontent.com/senola/pictures/master/angularjs/One_Way_Data_Binding.png" alt="One_Way_Data_Binding" /></p>

<p>大部分的templating系统仅仅是单向绑定数据，它们把template和model组件合并到一起，并在一个view里边展示。在合并发生之后，model或者关联view代码的改变不会自动的反映在view上。更糟糕的是任何用户在view组件上的改变都不会在model组件上反映。这就意味着开发者不得不编写代码来不断同步model及view的数据。</p>

<p>Data Binding in Angular Templates</p>

<p><img src="https://raw.githubusercontent.com/senola/pictures/master/angularjs/Two_Way_Data_Binding.png" alt="Two_Way_Data_Binding" /></p>

<p><code>AngularJs</code>的template工作模式不一样，首先template(未解析的、添加了标记（markup）和指令(directives)的HTML文件)在浏览器中解析的，解析的结果产生了视图(view),view中的任何改变都会立刻反射到model上，而model的任何改变也会立刻呈现在view上。这大大简化开发人员的编程model.由于view仅仅是model的数据渲染，所以控制器（controoler）完全从view中分离。所以，这就是的测试Controller变的很简单，因为不需要关联view。</p>

<h4>1.2 Angular 表达式（Expressions）</h4>

<p><code>Angular expressions</code> 是类似Javascript的代码段通常用于绑定，如：{{ expression }}。例如：下面是有效的<code>Angular expressions</code></p>

<pre><code> 1+2  
 a+b   
 user.name   
 items.[index]  
</code></pre>

<p>与<code>Javascript expressions</code>相比，<code>Angular expressions</code>有以下不同点：</p>

<pre><code>1. Conext(上下文)：在JavaScript expressions的值相对于全局的window(窗口)，而在Angular中，expression得值相对了一个scope(作用域)对象。   
2. forgiving（宽恕）:在JavaScript中求表达式值时若未定义的属性会发生“ReferenceError”或“TypeError”。而在Angular 中，express是被宽容的设置为“undefined”和“null”。
3. 没有控制流语句：在AngularJS中你不需要使用这些表达式：conditionals,loops或者exceptions。
4. Filters:你可以在展示expressions之前使用“filters”来格式化数据。
</code></pre>

<p>如果你想运行更复杂的JavaScript代码，你应该把它作为一个Controller方法在view中调用。如果你自己想eval()一个<code>Angular expression</code>，那么就使用 $eval()方法。</p>

<p>不像Javascript,默认定义的是全局的window属性，Angular expressions必须使用$window明确的指出为全局window对象。例如：假如你想在一个expression中调alert()函数，你必须用$window.alert()。这个限制是有意的,因为它能阻止意外的访问全局状态。</p>

<h4>1.3 Directives（指令）</h4>

<h5>1.3.1 what are Directives</h5>

<p>处于更高水准的，<code>Directives</code>是指那些在DOM元素（例如一个属性，元素名称，css class）上的标记，用来告诉<code>AngularJS</code> 的<strong>HTML compiler</strong>($compile解析器)给DOM元素附加一个特殊的行为或改变DOM元素及子元素。Angular 内置了一系列的<code>diresctives</code>,如：</p>

<p><code>ngBind</code>,<code>ngModel</code>,和<code>ngView</code></p>

<pre><code>What does it mean to "compile" an HTML template? For AngularJS, "compilation" 
means attaching event listeners to the HTML to make it interactive. The reason we   
use the term "compile" is that the recursive process of attaching directives      
mirrors the process of compiling source code in compiled programming languages.         
</code></pre>

<h5>1.3.2 Matching Directives(匹配指令)</h5>

<p>在我们编写一个<code>directive</code>之前，我们需要了解<code>Angular</code>的<code>HTML</code>解析器处理执行指令的过程。在一下的列子中，我们称<code>&lt;input&gt;</code>元素匹配<code>ngModel</code>指令:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;input ng-model="foo"&gt;</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>下面也一样能匹配<code>ngModel</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;input data-ng:model="foo"&gt;</span></code></pre></td></tr></table></div></figure>


<p></p>

<p><code>Angular</code>规范的命名了每一个元素的的标签和属性从而使得元素能和<code>directives</code>想匹配。通常要求指令是一些区分大小写、规范化的名字（如：ngModel）。然而,由于HTML是不区分大小写的,我们将指令在DOM中定为小写形式，通常使用<code>dash-delimited</code>的属性写在DOM元素(如ng-model)。标准化的处理如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Strip x- and data- from the front of the element/attributes.    
</span><span class='line'>Convert the :, -, or _-delimited name to camelCase.    </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>以下绑定效果是一样的（<a href="http://plnkr.co/edit/XWmTVHDmp6U57Nke9fmn?p=preview" target="_blank">Demo演示</a>）：</p>

<pre><code>&lt;div ng-controller="Controller"&gt;
  Hello &lt;input ng-model='name'&gt; &lt;hr/&gt;
  &lt;span ng-bind="name"&gt;&lt;/span&gt; &lt;br/&gt;
  &lt;span ng:bind="name"&gt;&lt;/span&gt; &lt;br/&gt;
  &lt;span ng_bind="name"&gt;&lt;/span&gt; &lt;br/&gt;
  &lt;span data-ng-bind="name"&gt;&lt;/span&gt; &lt;br/&gt;
  &lt;span x-ng-bind="name"&gt;&lt;/span&gt; &lt;br/&gt;
&lt;/div&gt;    
</code></pre>

<p>小贴士：</p>

<pre><code>Best Practice: Prefer using the dash-delimited format (e.g. ng-bind for ngBind).   
If you want to use an HTML validating tool, you can instead use the data-prefixed    
version (e.g. data-ng-bind for ngBind). The other forms shown above are accepted     
for legacy reasons but we advise you to avoid them.
</code></pre>

<p>基于元素的名称、属性名、类名<code>$compile</code>可以匹配directives.所有Angular提供的directives都能匹配属性名、标签名、comments或class名。</p>

<h5>Text and attribute binding(文本及属性绑定)</h5>

<p>编译器在编译过程中匹配文本和属性并使用<code>$interpolate</code>判断是否包含嵌入式表达式。如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;a ng-href="img/.jpg"&gt;Hello !&lt;/a&gt;</span></code></pre></td></tr></table></div></figure>


<h5>1.2.4 ngAttr 属性绑定</h5>

<p>Web浏览器对它们认为是正确的属性值有时候是很挑剔的。如：</p>

<pre><code>    &lt;svg&gt;
      &lt;circle cx=""&gt;&lt;/circle&gt;
    &lt;/svg&gt;
</code></pre>

<p>我们希望Angular能够正常绑定，但是当我们检查浏览器控制台时候我们会发现错误<code>Rrrpr:Invalid value for attribute cx=</code>。因为<code>SVG DOM API</code>的严格性，你不能简单的写成 <code>cx=</code>。采用<code>ng-attr-cx</code>你可以解决这个问题。也就是说如果一个属性的绑定前缀是<code>ngAttr</code>,那么在绑定时将被应用到相应的无前缀的属性：</p>

<pre><code> &lt;svg&gt;
  &lt;circle ng-attr-cx=""&gt;&lt;/circle&gt;
&lt;/svg&gt; 
</code></pre>

<h5>1.2.5 create directives</h5>

<p>首先，让我们了解一下<code>API for registering directives</code>,像<code>controller</code>一样,<code>directives</code>也是用modules注册。注册directive详情见<code>module.directive API</code>。<br/>
关于directive命名：</p>

<pre><code>Best Practice: In order to avoid collisions with some future standard, it's best    
to prefix your own directive names. For instance, if you created a &lt;carousel&gt;    
directive, it would be problematic if HTML7 introduced the same element. A two or     
three letter prefix (e.g. btfCarousel) works well. Similarly, do not prefix your    
owndirectives with ng or they might conflict with directives included in a future      
version of Angular. 
</code></pre>

<p>如下directive:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>angular.module('docsRestrictDirective', [])
</span><span class='line'>  .controller('Controller', ['$scope', function($scope) {
</span><span class='line'>    $scope.customer = {
</span><span class='line'>      name: 'Naomi',
</span><span class='line'>      address: '1600 Amphitheatre'
</span><span class='line'>    };
</span><span class='line'>  }])
</span><span class='line'>  .directive('myCustomer', function() {
</span><span class='line'>    return {
</span><span class='line'>      restrict: 'E',
</span><span class='line'>      templateUrl: 'my-customer.html'
</span><span class='line'>    };
</span><span class='line'>  });</span></code></pre></td></tr></table></div></figure>


<p></p>

<p><code>restrict</code>的可选参数有：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>'A' - only matches attribute name
</span><span class='line'>'E' - only matches element name
</span><span class='line'>'C' - only matches class name</span></code></pre></td></tr></table></div></figure>


<p>
这些限制条件可以被组合使用：如 ‘AEC-matches either attribute or element or class name’。默认为&#8217;A&#8217;。</p>

<h5>1.2.6 creating a directive that Manipulates the DOM</h5>

<p>下面一个例子是展示当前时间，并且每过一秒钟，DOM时间也跟着更新 <a href="http://plnkr.co/edit/ngdoc:example-example86@snapshot?p=preview" target="_blank"><strong>Demo</strong></a>。 <br/>
directive若要修改DOM则需要使用<code>link</code>选项。<code>link</code>能接收一个有一下参数的function，<code>function link(scope,element,attrs){...}</code>:</p>

<ul>
<li><code>scope</code>:一个Angular作用域对象</li>
<li><code>element</code>:directive 匹配的<code>jqLite-wrapped</code>元素</li>
<li><code>attrs</code>:是一个散列对象的键值对,有着规范化属性名称及其对应的属性值</li>
</ul>


<h3>1.2.7 Filters</h3>

<p><code>filter</code>是用来格式化一个表达式的值的。他们能在<code>view template</code>、<code>controller</code>和<code>service</code>中使用，你能很方便的定义自己的<code>filter</code>。</p>

<h4>（1） 在view templates中使用filter</h4>

<p>Filters能在<code>view tmeplate</code>中的表达式中使用，语法如下：</p>

<p>比如：标记12 表示使用<code>currency</code>filter 格式化数字12为货币形式。结果为：$12.00。<br/>
Filters 能使用一系列的filter,这称为“chaining(链)”，语法如下：</p>

<p>Filters也可以携带参数，语法如下：</p>

<p>例如：标记<code>1234</code>表示数字1234使用<code>number</code>过滤器过滤保留2位小数点，结果为：1，234.00。</p>

<h4>（2）在controller,services,和directives中使用filters</h4>

<p>在controller,services,和directives中使用filters你需要给他们注入依赖<code>&lt;filterName&gt;Filter</code>。例如,使用依赖<code>numberFilter</code>会注入<code>number</code>过滤器。见<a href="http://plnkr.co/edit/ngdoc:example-example96@snapshot?p=preview" target="_blank"><strong>demo</strong></a>。</p>

<h4>（3）创建自定义filters</h4>

<p>编写自己的filter很简单，仅仅需要在<code>module</code>中注册一个新的<code>filter factory</code>函数。在内部，使用了<code>filterProvider</code>。<code>factory</code>函数需要一个新的<code>filter</code>函数，该函数的第一个参数为需要过滤的表达式的值。见<a href="http://plnkr.co/edit/ngdoc:example-example97@snapshot?p=preview" target="_blank"><strong>demo</strong></a>。</p>

<h3>表单（Forms）</h3>

<p>通常，<code>input</code>、<code>select</code>、<code>textarea</code>等控件是用来给用户输入数据的。而<code>Forms</code>是对这些控件的一种集合。<code>Angular</code>的<code>Form</code>和<code>controls(控件)</code>提供了数据验证服务，所以用户可以避免无效输入。这些功能能给用户更好的体验。</p>

<h5>（1）simple form(简单的表单)</h5>

<p>理解双向绑定（data-binding）的关键指令（directive）是<code>ngModel</code>。<code>ngModel</code>指令提供的双向绑定功能能使<code>model</code>和<code>view</code>数据自动同步。另外，它提供了一个API给其他的<code>directive</code>来增强它的功能。见<a href="http://plnkr.co/edit/ngdoc:example-example98@snapshot?p=preview" target="_blank"><strong>demo</strong></a>。</p>

<pre><code>    &lt;div ng-controller="Controller"&gt;
      &lt;form novalidate class="simple-form"&gt;
        Name: &lt;input type="text" ng-model="user.name" /&gt;&lt;br /&gt;
        E-mail: &lt;input type="email" ng-model="user.email" /&gt;&lt;br /&gt;
        Gender: &lt;input type="radio" ng-model="user.gender" value="male" /&gt;male
        &lt;input type="radio" ng-model="user.gender" value="female" /&gt;female&lt;br /&gt;
        &lt;button ng-click="reset()"&gt;RESET&lt;/button&gt;
        &lt;button ng-click="update(user)"&gt;SAVE&lt;/button&gt;
      &lt;/form&gt;
      &lt;pre&gt;form = &lt;/pre&gt;
      &lt;pre&gt;master = &lt;/pre&gt;
    &lt;/div&gt;

    &lt;script&gt;
      function Controller($scope) {
        $scope.master = {};

        $scope.update = function(user) {
          $scope.master = angular.copy(user);
        };

        $scope.reset = function() {
          $scope.user = angular.copy($scope.master);
        };

        $scope.reset();
      }
    &lt;/script&gt;  
</code></pre>

<p>注意<code>novalidate</code>是用来禁用浏览器的表单验证。</p>

<h5>（2）使用CSS classes</h5>

<p>为了想控件一样定义样式，<code>ngModel</code>增加了一下CSS classes:</p>

<ul>
<li>ng-valid</li>
<li>ng-invalid</li>
<li>ng-pristine</li>
<li>ng-dirty</li>
</ul>


<p>其效果见<a href="http://plnkr.co/edit/ngdoc:example-example99@snapshot?p=preview" target="_blank"><strong>demo</strong></a>。</p>

<h4>(3) 绑定表单及控制状态</h4>

<p>一个<code>form</code>是一个<code>FormController</code>的实例，<code>form</code>实例的<code>name</code>属性可以请求到<code>scope</code>中。类似的，一个<code>input</code>含有<code>ngModel</code>的控件会拥有一个<code>NgModelController</code>的实例。这允许我们扩展一些特性如:</p>

<ul>
<li>RESET button is enabled only if form has some changes</li>
<li>SAVE button is enabled only if form has some changes and is &ndash; valid</li>
<li>custom error messages for user.email and user.agree-</li>
</ul>


<h4>(4) custom tirggers</h4>

<p>默认地，任何的内容改变都会触发<code>model</code>的更新和<code>form</code>的验证。您可以使用<code>ngModelOptions</code>指令覆盖此行为将只绑定到指定的事件列表。如：<code>ng-model-option="{updateOn:"blur"}"</code>当控件失去焦点时候会进行更新和验证。你还可以设置几个事件使用空格分隔如：</p>

<pre><code>`ng-model-options="{updateOn:"mousedown blur"}"`。
</code></pre>

<p>如果你想保留默认的行为和增加新的事件来触发<code>model</code>的更新和验证：</p>

<pre><code>ng-model-options="{ updateOn: 'default blur' }"
</code></pre>

<h4>(5) 推迟model更新时间</h4>

<p>你可以使用<code>ngModelOption</code>指令的key <code>debounce</code>来延迟<code>model</code>的更新和验证时间。这种延迟也会适用于解析器，<code>validators</code> 和 <code>model</code>的标记为<code>$dirty</code>和<code>$pristine</code>。如<code>ng-model-options="{debounce: 500}"</code>表示当内容发生变化后在经过0.5秒才会触发<code>model</code>的更新和<code>form</code>的验证。在特殊环境这能很有效的阻止立刻更新（如：blur事件）</p>

<pre><code>ng-model-options="{updateOn:'default blur',debounce:{default:500,blur:0}}" 
</code></pre>

<p>如果是用在一个元素上面，则该原色的全部子元素和控件都会从它那继承，除非子元素是隐藏的。见<a href="http://plnkr.co/edit/ngdoc:example-example102@snapshot?p=preview" target="_blank"><strong>demo</strong></a></p>

<h4>(6) 自定义验证</h4>

<p>Angular 提供了html5常用的输入类型：（<code>text</code>,<code>number</code>,<code>url</code>,<code>email</code>,<code>radio</code>,<code>checkbox</code>）,同时也提供了一些验证指令（<code>required</code>,<code>pattern</code>,<code>minlength</code>,<code>maxlength</code>,<code>min</code>,<code>max</code>）。定义你自己的验证可以给<code>ngModel Controller</code>定义你自己的<code>directive</code>的时候增加一个自定义的<code>validation function</code>.两种情况下可能需要自定义验证：</p>

<ul>
<li><strong>Model to View update</strong>: 只要绑定的模型发生改变，所有在<code>NgModelController#$formatters</code>的函数数组都是<code>pipe-lined</code>,通过<code>NgModelController#$setValidity</code>这些函数都有机会还改变或者验证控件和表单。</li>
<li><strong>View to Model update</strong>:同样的方式，当用户和一个控件交互时，它会调用<code>NgModelController#$setViewValue</code>。 <br/>
英文太烂硬是没看懂，蛋疼! 见<a href="http://plnkr.co/edit/ngdoc:example-example103@snapshot?p=preview" target="_blank"><strong>demo</strong></a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[猿形]]></title>
    <link href="http://senola.github.io/blog/2014/03/11/0005/"/>
    <updated>2014-03-11T06:54:11+08:00</updated>
    <id>http://senola.github.io/blog/2014/03/11/0005</id>
    <content type="html"><![CDATA[<p>码农，就是一群整天敲着代码的农民，人们称之为“程序猿”。</p>

<p>三月份，码农们也开始忙碌了。</p>

<p>或许是猿儿太累太压抑了，他忽然觉得没有了动力，</p>

<p>曾经成为一代猿神的梦想也成为了一段笑话。</p>

<!--more-->


<p>时间在匆忙流逝，猿儿却颇感无力。</p>

<p>猿儿也有过雄心，有过奋起，只是总被现实击败。</p>

<p>面对挫折猿儿有些泄气，不知所措。</p>

<p>现在，他正处于迷茫期，</p>

<p><a href="http://senola.github.io/collections/mywords/20140310.html" target="_blank">何时才能进化，猿儿甚是烦心！</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git学习]]></title>
    <link href="http://senola.github.io/blog/2014/02/28/0004/"/>
    <updated>2014-02-28T06:43:55+08:00</updated>
    <id>http://senola.github.io/blog/2014/02/28/0004</id>
    <content type="html"><![CDATA[<p>每天学一点，每天成长一天。。。<br/>
git基础知识，没事看看，多看看！！!<br/>
<a href="http://senola.github.io/collections/git/git.html" target="_blank" ><strong>git基础</strong></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[迷路]]></title>
    <link href="http://senola.github.io/blog/2014/02/24/0003/"/>
    <updated>2014-02-24T04:57:44+08:00</updated>
    <id>http://senola.github.io/blog/2014/02/24/0003</id>
    <content type="html"><![CDATA[<p>今天，又迷路了&hellip;</p>

<p>为什么说“又”呢，哎!也许是命中注定，打小时候咱的方向感就几乎为零，也就是走着走着就回丢掉的那种。这也是我为什么选择学理科的原因之一，哎~</p>

<p>最近一段时间挺忙的，忙的有些喘不过气。在电脑前呆久了整个人都变得些许麻木，所以趁着周末背个包独自去紫金山散散心，找找感觉。紫金山位于南京东郊，又称钟山，自古被誉为江南四大名山，有“金陵毓秀”的美誉，是南京名胜古迹荟萃之地，全国生态文化示范地、世界文化遗产所在地、首批国家5A级景区钟山风景名胜区位于钟山南麓。<!--more-->look!当然，这是百度百科的，我看到的没有这么秀美，不过却也别有一番风味。</p>

<p><img src="http://raw.github.com/senola/pictures/master/climb_mountain/%E7%B4%AB%E9%87%91%E5%B1%B1.jpg" alt="Landing page" /></p>

<p>说起来真坑爹，九点出门。跟着百度地图一路瞎绕。百度是这样说的：从仙鹤门到下马坊下，再从旅游专线2号线到明孝陵，下车后像东北走6640米即可。哥，你这是玩我吧，不带这么坑的。我知道东北方向是什么方向我还在这混？于是，在紫霞湖旁边一直游荡。PS：旁边也有好些人在问紫金山怎么走，但是给出的答案都是听不懂云云。。。N久之后又走到了中山陵，这表示亚历山大。。。</p>

<p><img src="http://raw.github.com/senola/pictures/master/climb_mountain/%E4%B8%AD%E5%B1%B1%E9%99%B5.jpg" alt="Landing page" /></p>

<p>也许是孙先生的保佑，加上我多年的迷路经验，再加上这张破损孙的地图。我决定去探险：绕过中山陵，直插半山腰。途中经过一段十五分钟的林荫道，那是一段充满着沉重气息的地方。有着茂密的树林、积厚的落叶、虫鸣、鸟叫，这是一种荒凉的感觉。没人人影，有的只是微风和那沙沙作响的树叶，再加上偶尔传来的几声鸟鸣、忽然窜出的野猫和一个孤单的自己，不可否认，我有些害怕了。这样一段路，短暂的十几分钟，我做了多次思想斗争。前面的路是一片未知，而人类天生就对未知充满着好奇与恐惧，这一刻我有些退缩了。</p>

<p><img src="http://raw.github.com/senola/pictures/master/climb_mountain/%E6%A0%91%E6%9E%97001.jpg" alt="Landing page" /></p>

<p>最后我还是走下去了，原因有两点：一、这路是人铺的，那么前方一定有人走过，第一个吃螃蟹的人还轮不到我。二、路边有些显眼、不算太旧的垃圾袋告诉我，这路平常定有人走过，即使不安全也不会太不安全。带着这几个谬论前进十几分钟后，我终于看到了人影&hellip;</p>

<p><img src="http://raw.github.com/senola/pictures/master/climb_mountain/%E6%A0%91%E6%9E%97002.jpg" alt="Landing page" /></p>

<p>这一刻我似乎明白了一个道理：当下，自己所走的路不是在开拓，而是在重蹈。路别人都已走过，只是自己不曾注意而已。</p>

<p><img src="http://raw.github.com/senola/pictures/master/climb_mountain/%E6%A0%91%E6%9E%97005.jpg" alt="Landing page" /></p>

<p>登山，从此刻开始。想想，已经好多年没登山了。我觉得登山时一种体验，一种磨练，更是一种调节自我的运动。</p>

<p><img src="http://raw.github.com/senola/pictures/master/climb_mountain/%E7%99%BB%E5%B1%B1.jpg" alt="Landing page" /></p>

<p>体验极限，激发能量，抛弃一切烦恼，其实我还年轻。。。</p>

<p><img src="http://raw.github.com/senola/pictures/master/climb_mountain/%E8%AF%B4%E9%81%93.jpg" alt="Landing page" /></p>

<p>登高望远，俯瞰大地，远离喧嚣，阔我胸怀，觅一份宁静。。。</p>

<p><img src="http://raw.github.com/senola/pictures/master/climb_mountain/%E4%BF%AF%E7%9E%B0%E5%8D%97%E4%BA%AC.jpg" alt="Landing page" /></p>

<p>下午三点，踩着顺着一个个阶梯缓缓而下，我只知道到山底的那一刻，我的双腿是软的，即将抽筋的那种。下山后又傻了，神呐，这又是哪！！樱陀村，一个没地铁的地方。于是，买了个饼边啃边问人。。。</p>

<p>路，从脚下连接着远方，远方的路是什么？我不怕迷路，只怕迷失自己。我可以找到回家的路，却怕找不回迷失的自己。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在github上用Octopress搭建博客的方法]]></title>
    <link href="http://senola.github.io/blog/2014/02/11/0002/"/>
    <updated>2014-02-11T06:00:56+08:00</updated>
    <id>http://senola.github.io/blog/2014/02/11/0002</id>
    <content type="html"><![CDATA[<h3>一、Octopress及Github简介</h3>

<p><a href="http://octopress.org">Octopress</a> 是一款优秀的静态化博客系统，也是一个本地化的博客系统，Github为我们提供长期稳定的免费空间服务，但是Github空间不是一般意义上的PHP或者ASP空间。</p>

<p><a href="https://github.com/">Github</a> 是一个代码托管空间，我们常用的一些PHP应用程序都无法在Github空间上运行。Octopress作为一个本地化的博客，官方将它简称为：“A blogging framework for hackers.”，也就是Octopress只适合那些经常玩Linux、写代码的朋友用的博客系统。  <!--more-->
<code>Octopress</code>博客最大的优势就是静态化，不依赖脚本程序，没有MysqL等数据库，因此它可以在一些性能差的服务器或者虚拟空间上运行，在同等条件下打开页面的速度自然也是非常快。<br/>
<code>Octopress</code>支持自定义模板，可以markdown，文本文件写作、保存可以直接用dropbox等网盘来同步。另外它还可以让你有git版本控制功能。<code>octopress</code>还有个优点就是它的整个使用发布是个松耦合的结构，相信一些习惯了代码的朋友很喜欢。</p>

<h3>二、安装Octopress运行的必要软件</h3>

<blockquote><ol>
<li>官方首页：<a href="http://octopress.org">http://octopress.org</a></li>
<li>这里是<a href="http://dl.bintray.com/oneclick/rubyinstaller/rubyinstaller-1.9.3-p484.exe?direct">RubyInstaller</a>下载地址。</li>
<li>这里是<a href="http://cloud.github.com/downloads/oneclick/rubyinstaller/DevKit-tdm-32-4.5.2-20111229-1559-sfx.exe">DevKit</a>下载地址。</li>
</ol>
</blockquote>

<p>安装好ruby后，win键+R，输入cmd进入控制台。可以输入<code>ruby -version</code>可查看ruby安装的本版信息。接着用CD的命令进入你存放DevKit的目录中，DevKit只需解压到一个文件夹:</p>

<p><img src="http://corey600.github.io/images/20130228/dkiu.jpg" alt="devkit.png" /></p>

<p>执行以下命令继续安装:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ruby dk.rb init       
</span><span class='line'>ruby dk.rb install</span></code></pre></td></tr></table></div></figure>


<p>之后会有如下输出：</p>

<p><img src="https://raw.githubusercontent.com/senola/pictures/master/octopress-tutorial/devkit-load.png" alt="devkit-load.png" /></p>

<p>虽然不知道这鸟玩意儿是作甚的，但是不执行的话，后面的<code>bundle install</code>是死活安装不了，会出现各种BUG，我试过的，作死！！！</p>

<p>接着<code>cd</code>到博客根目录，需要安装所需依赖：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  gem install bundler
</span><span class='line'>  bundle install</span></code></pre></td></tr></table></div></figure>


<p>但是，在天朝这个国度，这个是行不通的。没办法，得改变一个软件更细源，邮件&mdash;>git bash,输入：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gem sources -a http://ruby.taobao.org/
</span><span class='line'>gem sources -r http://rubygems.org/
</span><span class='line'>gem sources -l</span></code></pre></td></tr></table></div></figure>


<p><img src="http://corey600.github.io/images/20130228/ociu.jpg" alt="ociu" /></p>

<p>接着，打开Octopress安装目录下的D:\Blog\Gemfile，将第一行的source改成国内淘宝的<a href="http://ruby.taobao.org/">http://ruby.taobao.org/</a></p>

<p><img src="http://corey600.github.io/images/20130228/ociu3.jpg" alt="ociu3" /></p>

<p>然后上边的依赖就可以正常安装了，TM 卡在这N久了~~</p>

<h3>三、git 和 github 配置</h3>

<p>1.先注册一个github账号,创建github pages创建一个新的<code>Repository</code>。这里须要重视的是，若是想要博客的首页是<code>http://yourname.github.com</code>则Repository的<code>project name</code>就必须是<code>yourname.github.com</code>。
未完待续&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[这一天]]></title>
    <link href="http://senola.github.io/blog/2014/02/10/0001/"/>
    <updated>2014-02-10T01:50:34+08:00</updated>
    <id>http://senola.github.io/blog/2014/02/10/0001</id>
    <content type="html"><![CDATA[<p>很无奈的说，整了一天<code>github pages</code>和<code>Octopress</code>也才整成这样，十分感叹自己的能力。不过却也有一些收获：比如我终于搭建了一个博客，了解了如何搭建个人博客的过程。总的说今天收获蛮大啊！给自个一个赞O(∩_∩)O~</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1. 人有两条路要走，一条是必须走的，一条是想走的，你必须把必须走的路走漂亮，才可以走想走的路。  
</span><span class='line'>2. 修行之道：关注大师的言行，跟随大师的举动，和大师一并修行，领会大师的意境，成为真正的大师。</span></code></pre></td></tr></table></div></figure>


<!--more-->

]]></content>
  </entry>
  
</feed>
